import type { PROVIDERS } from './enums';
import { ProviderDetector } from './provider-detector';
import type { Chain, ChainId, IProvider, ProviderEventCallback, ProviderEventPayload, ProviderInstance, ProviderListeners, ProviderProxy, ProviderProxyConstructor, RawProvider, TransactionResponse, TxRequestBody } from './types';
export type CreateProviderOpts<T extends keyof Record<string, string>> = {
    providerDetector?: ProviderDetector<T>;
    listeners?: ProviderListeners;
};
/**
 * @description Represents a browser-based wallet.
 *
 * To connect to a wallet, create an object to represent the wallet to access with the `createProvider()` method. These wallet objects implement the `Provider` interface so you can access different types of wallets in a consistent way.
 *
 * @example
 * ```js
 * import { createProvider, MetamaskProvider } from '@rarimo/provider'
 *
 * const getMetamaskWalletAddress = async () => {
 *   // Connect to the Metamask wallet in the browser using ethers.js, using the MetamaskProvider interface to limit bundle size.
 *   const provider = await createProvider(MetamaskProvider)
 *
 *   // Get the address of the wallet
 *   console.log(provider.address)
 * }
 * ```
 */
export declare class Provider implements IProvider {
    readonly proxyConstructor: ProviderProxyConstructor;
    selectedProvider?: PROVIDERS;
    proxy?: ProviderProxy;
    static chainsDetails?: Record<ChainId, Chain>;
    constructor(proxyConstructor: ProviderProxyConstructor);
    get rawProvider(): RawProvider | undefined;
    get chainType(): import("./enums").CHAIN_TYPES | undefined;
    get providerType(): PROVIDERS | undefined;
    get isConnected(): boolean;
    get address(): string | undefined;
    get chainId(): ChainId | undefined;
    get chainDetails(): Chain | undefined;
    init(provider: ProviderInstance, listeners?: ProviderListeners): Promise<this>;
    connect(): Promise<void>;
    switchChain(chainId: ChainId): Promise<void>;
    addChain(chain: Chain): Promise<void>;
    static setChainsDetails(chains: Record<ChainId, Chain>): void;
    signAndSendTx(txRequestBody: TxRequestBody): Promise<TransactionResponse>;
    getHashFromTx(txResponse: TransactionResponse): string;
    getTxUrl(chain: Chain, txHash: string): string;
    getAddressUrl(chain: Chain, address: string): string;
    signMessage(message: string): Promise<string>;
    onAccountChanged(cb: (e?: ProviderEventPayload) => void): void;
    onChainChanged(cb: (e?: ProviderEventPayload) => void): void;
    onConnect(cb: (e?: ProviderEventPayload) => void): void;
    onDisconnect(cb: (e?: ProviderEventPayload) => void): void;
    onInitiated(cb: (e?: ProviderEventPayload) => void): void;
    clearHandlers(): void;
    onBeforeTxSent(cb: (e?: ProviderEventPayload) => void): void;
    onTxSent(cb: (e?: ProviderEventPayload) => void): void;
    onTxConfirmed(cb: (e?: ProviderEventPayload) => void): void;
    onWalletConnectDisplayUri(cb: ProviderEventCallback): void;
    disconnect(): Promise<void>;
}
/**
 * @description Creates an instance of a wallet provider
 *
 * @example
 * const provider = await createProvider(MetamaskProvider)
 * await provider.init()
 * // or
 * const providerDetectorInstance = await new ProviderDetector().init()
 * const metamaskProvider = await createProvider(MetamaskProvider, { providerDetectorInstance })
 * const phantomProvider = await createProvider(PhantomProvider, { providerDetectorInstance })
 * // When using WalletConnectEvmProvider, it's required to set chainsDetails:
 * Provider.setChainsDetails(chainsDetails)
 */
export declare function createProvider<T extends keyof Record<string, string>>(proxy: ProviderProxyConstructor, opts?: CreateProviderOpts<T>): Promise<Provider>;
