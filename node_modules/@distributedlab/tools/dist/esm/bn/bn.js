function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _class_private_method_get(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _class_private_method_init(obj, privateSet) {
    _check_private_redeclaration(obj, privateSet);
    privateSet.add(obj);
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
import { DEFAULT_BN_PRECISION } from "../const";
import { BN_ASSERT_DECIMALS_OP, BN_ROUNDING, DECIMALS } from "../enums";
import { assert, isHex, isIntegerString } from "../helpers";
import { assertDecimals, assertDecimalsInteger } from "./assertions";
import { getTens, toDecimals } from "./decimals";
import { format as _format } from "./format";
import { parseConfig, parseNumberString } from "./parsers";
import { round } from "./round";
let globalConfig = {
    precision: DEFAULT_BN_PRECISION,
    rounding: BN_ROUNDING.DEFAULT,
    decimals: DECIMALS.WEI,
    format: {
        prefix: '',
        decimalSeparator: '.',
        groupSeparator: ',',
        groupSize: 3,
        fractionGroupSeparator: ' ',
        fractionGroupSize: 0,
        suffix: ''
    }
};
var _raw = new WeakMap(), _cfg = new WeakMap(), _tens = new WeakMap(), _one = new WeakMap(), _hundred = new WeakMap(), _toDecimals = new WeakSet(), _percentToFraction = new WeakSet();
export class BN {
    /**
   * Solidity maximum uint256 value.
   */ static get MAX_UINT256() {
        return BN.fromBigInt(2n ** 256n - 1n, 1);
    }
    static get WEI_DECIMALS() {
        return DECIMALS.WEI;
    }
    static get ROUNDING() {
        return BN_ROUNDING;
    }
    /**
   * {@link BN} class global config.
   */ static get config() {
        return globalConfig;
    }
    /**
   * {@link BN} class global precision.
   */ static get precision() {
        return globalConfig.precision;
    }
    /**
   * Sets new {@link BnGlobalConfig} config to the {@link BN}.
   */ static setConfig(config) {
        globalConfig = _object_spread({}, globalConfig, config);
    }
    /**
   *
   * @returns `true` if `arg` is {@link BN} instance.
   */ static isBn(arg) {
        return arg instanceof BN;
    }
    /**
   * @returns A new {@link BN} if `value` argument is valid big int like value,
   * otherwise throws {@link RuntimeError}.
   *
   * @example
   * ```ts
   * const oneEth = BN.fromBigInt('1000000000000000000', 18)
   * ```
   */ static fromBigInt(value, decimalsOrConfig) {
        let val = value;
        if (typeof val === 'string') {
            val = isHex(val) ? BigInt(val).toString() : val;
            assert(isIntegerString(val), 'Invalid big int string');
        }
        const cfg = parseConfig(decimalsOrConfig !== null && decimalsOrConfig !== void 0 ? decimalsOrConfig : BN.config.decimals);
        const parsed = BigInt(BN.isBn(val) ? val.value : val);
        const withPrecision = parsed * getTens(BN.precision - cfg.decimals);
        return new BN(withPrecision, cfg);
    }
    /**
   * @returns A new {@link BN} if `value` argument is valid integer or float value,
   * otherwise throws {@link RuntimeError}.
   * @example
   * ```ts
   * const oneEth = BN.fromRaw(1, 18)
   * ```
   */ static fromRaw(value, decimalsOrConfig) {
        const val = String(value);
        const cfg = parseConfig(decimalsOrConfig !== null && decimalsOrConfig !== void 0 ? decimalsOrConfig : BN.config.decimals);
        return new BN(BigInt(parseNumberString(val)), cfg);
    }
    /**
   *  @returns A minimum {@link BN} value from the `args`.
   */ static min(...args) {
        return args.reduce((min, el)=>el.raw < min.raw ? el : min);
    }
    /**
   *  @returns A maximum {@link BN} value from the `args`.
   */ static max(...args) {
        return args.reduce((min, el)=>el.raw > min.raw ? el : min);
    }
    /**
   *  @returns A `this` config.
   */ get config() {
        return _class_private_field_get(this, _cfg);
    }
    /**
   *  @returns The number of decimal places
   */ get decimals() {
        return _class_private_field_get(this, _cfg).decimals;
    }
    /**
   *  @returns `true` if the `this` value is zero.
   */ get isZero() {
        return _class_private_field_get(this, _raw) === 0n;
    }
    /**
   *  @returns `true` if the `this` value is positive.
   */ get isPositive() {
        return _class_private_field_get(this, _raw) > 0n;
    }
    /**
   *  @returns `true` if the `this` value is negative.
   */ get isNegative() {
        return _class_private_field_get(this, _raw) < 0n;
    }
    /**
   *  @returns A raw {@link BigInt} value with the {@link BN.precision} applied.
   */ get raw() {
        return _class_private_field_get(this, _raw);
    }
    /**
   *  @returns A big int string value with the `this.decimals` applied.
   */ get value() {
        return toDecimals(_class_private_field_get(this, _raw), BN.precision, _class_private_field_get(this, _cfg).decimals).toString();
    }
    /**
   *  @returns A new {@link BN} with the result of this added to `other`.
   */ add(other) {
        return new BN(_class_private_field_get(this, _raw) + other.raw, _class_private_field_get(this, _cfg));
    }
    /**
   *  @returns A new {@link BN} with the result of other subtracted from this.
   */ sub(other) {
        return new BN(_class_private_field_get(this, _raw) - other.raw, _class_private_field_get(this, _cfg));
    }
    /**
   *  @returns A new {@link BN} with the result of this divided by `other`.
   */ div(other) {
        assert(other.raw !== 0n, 'Cannot divide by zero');
        return new BN(_class_private_field_get(this, _raw) * _class_private_field_get(this, _tens) / other.raw, _class_private_field_get(this, _cfg));
    }
    /**
   *  @returns A new {@link BN} with the result of this multiplied by `other`.
   */ mul(other) {
        return new BN(_class_private_field_get(this, _raw) * other.raw / _class_private_field_get(this, _tens), _class_private_field_get(this, _cfg));
    }
    /**
   *  @returns A comparison result between this and other.
   */ cmp(other) {
        const a = _class_private_field_get(this, _raw);
        const b = other.raw;
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
    }
    /**
   *  @returns `true` if `other` is equal to `this`.
   */ eq(other) {
        return this.cmp(other) === 0;
    }
    /**
   *  @returns `true` if `other` is less than to `this`.
   */ lt(other) {
        return this.cmp(other) < 0;
    }
    /**
   *  @returns `true` if `other` is less than or equal to `this`.
   */ lte(other) {
        return this.cmp(other) <= 0;
    }
    /**
   *  @returns `true` if `other` is greater than to `this`.
   */ gt(other) {
        return this.cmp(other) > 0;
    }
    /**
   *  @returns `true` if `other` is greater than or equal to `this`.
   */ gte(other) {
        return this.cmp(other) >= 0;
    }
    /**
   * @returns A new {@link BN} whose value is the square root of `this`.
   * @throws {@link RuntimeError} if `BN.precision` is not even number.
   */ sqrt() {
        assert(!this.isNegative, 'sqrt of negative numbers is not supported');
        if (this.isZero) return this;
        const base = this.raw * _class_private_field_get(this, _tens);
        let x0 = base / 2n;
        let x1 = (x0 + base / x0) / 2n;
        while(x0 - x1 > 1n){
            x0 = x1;
            x1 = (x0 + base / x0) / 2n;
        }
        return new BN(x1, _class_private_field_get(this, _cfg));
    }
    /**
   * @returns A new {@link BN} whose value is negated `this` (multiplied by -1).
   */ negated() {
        return new BN(_class_private_field_get(this, _raw) * -1n, _class_private_field_get(this, _cfg));
    }
    /**
   * @returns A new {@link BN} whose value is absolute `this`.
   */ abs() {
        return this.isPositive ? this : this.negated();
    }
    /**
   * @returns A new {@link BN} whose value is `this` raised to the power of `exponent`.
   */ pow(exponent) {
        assertDecimalsInteger(exponent);
        const exp = BigInt(exponent);
        const fr = getTens(Number(BigInt(BN.precision) * (exp - 1n)));
        return new BN(_class_private_field_get(this, _raw) ** exp / fr, _class_private_field_get(this, _cfg));
    }
    /**
   * @returns A new {@link BN} whose value is percentage of `this` value.
   */ percent(percent) {
        return this.mul(_class_private_method_get(this, _percentToFraction, percentToFraction).call(this, percent));
    }
    /**
   * @returns A new {@link BN} whose value is `this` with added percentage.
   */ addPercent(percent) {
        return this.mul(_class_private_field_get(this, _one).add(_class_private_method_get(this, _percentToFraction, percentToFraction).call(this, percent)));
    }
    /**
   * @returns A new {@link BN} whose value is `this` with subtracted percentage.
   */ subPercent(percent) {
        return this.div(_class_private_field_get(this, _one).add(_class_private_method_get(this, _percentToFraction, percentToFraction).call(this, percent)));
    }
    /**
   * @returns A new {@link BN} with the provided decimals.
   */ toDecimals(decimals) {
        if (decimals === _class_private_field_get(this, _cfg).decimals) return this;
        return decimals > _class_private_field_get(this, _cfg).decimals ? this.toGreaterDecimals(decimals) : this.toLessDecimals(decimals);
    }
    /**
   * @returns A new {@link BN} with the provided decimals, less than current one,
   * otherwise throws {@link RuntimeError}.
   */ toLessDecimals(decimals) {
        assertDecimals(_class_private_field_get(this, _cfg).decimals, decimals, BN_ASSERT_DECIMALS_OP.LESS);
        return _class_private_method_get(this, _toDecimals, toDecimals1).call(this, decimals);
    }
    /**
   * @returns A new {@link BN} with the provided decimals, greater than current one,
   * otherwise throws {@link RuntimeError}.
   */ toGreaterDecimals(decimals) {
        assertDecimals(_class_private_field_get(this, _cfg).decimals, decimals, BN_ASSERT_DECIMALS_OP.GREATER);
        return _class_private_method_get(this, _toDecimals, toDecimals1).call(this, decimals);
    }
    /**
   * @returns A string representing the value of `this` fixed-point notation and
   * formatted according to the properties of the {@link BN.config.format} and
   * `format` (if exist) objects.
   */ format(format = {}) {
        return _format(this.toString(), _object_spread({}, BN.config.format, format));
    }
    /**
   * @returns A new {@link BN} whose value is the value of `this` rounded to
   * decimals using {@link BN_ROUNDING} rounding mode.
   */ round(decimals, rounding) {
        return BN.fromBigInt(round(this, decimals, rounding !== null && rounding !== void 0 ? rounding : BN.config.rounding), _object_spread_props(_object_spread({}, _class_private_field_get(this, _cfg)), {
            decimals
        }));
    }
    /**
   * @returns A human-readable float string.
   */ toString() {
        let val = this.value;
        const decimals = _class_private_field_get(this, _cfg).decimals;
        const negative = this.isNegative ? '-' : '';
        const isLessOne = val.length < decimals;
        if (this.isNegative) val = val.slice(1);
        if (isLessOne) val = val.padStart(decimals, '0');
        const pointIdx = val.length - decimals;
        val = val.slice(0, pointIdx) + '.' + val.slice(pointIdx);
        if (val.startsWith('.')) val = '0' + val;
        return negative + val;
    }
    /**
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description}
   */ toJSON() {
        return this.value;
    }
    /**
   *
   * @param value - Always BigInt * ten power of {@link BN.precision}
   * @param config - The config of the value.
   * @protected
   * @returns A new {@link BN} instance.
   */ constructor(value, config){
        _class_private_field_init(this, _one, {
            get: get_one,
            set: void 0
        });
        _class_private_field_init(this, _hundred, {
            get: get_hundred,
            set: void 0
        });
        _class_private_method_init(this, _toDecimals);
        _class_private_method_init(this, _percentToFraction);
        /**
   * Raw value multiplied by ten power of {@link BN.precision}.
   */ _class_private_field_init(this, _raw, {
            writable: true,
            value: void 0
        });
        /**
   * {@link BN} instance config.
   */ _class_private_field_init(this, _cfg, {
            writable: true,
            value: void 0
        });
        /**
   * Ten power of {@link BN.precision}.
   */ _class_private_field_init(this, _tens, {
            writable: true,
            value: getTens(BN.precision)
        });
        _class_private_field_set(this, _raw, value);
        _class_private_field_set(this, _cfg, config);
    }
} /*#__PURE__*/  /*#__PURE__*/  /*#__PURE__*/  /*#__PURE__*/  /*#__PURE__*/  /*#__PURE__*/  /*#__PURE__*/ 
function get_one() {
    return BN.fromRaw(1, _class_private_field_get(this, _cfg));
}
function get_hundred() {
    return BN.fromRaw(100, _class_private_field_get(this, _cfg));
}
function toDecimals1(decimals) {
    return new BN(_class_private_field_get(this, _raw), _object_spread_props(_object_spread({}, _class_private_field_get(this, _cfg)), {
        decimals
    }));
}
function percentToFraction(percent) {
    return BN.fromRaw(percent, _class_private_field_get(this, _cfg)).div(_class_private_field_get(this, _hundred));
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ibi9ibi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUZBVUxUX0JOX1BSRUNJU0lPTiB9IGZyb20gJ0AvY29uc3QnXG5pbXBvcnQgeyBCTl9BU1NFUlRfREVDSU1BTFNfT1AsIEJOX1JPVU5ESU5HLCBERUNJTUFMUyB9IGZyb20gJ0AvZW51bXMnXG5pbXBvcnQgeyBhc3NlcnQsIGlzSGV4LCBpc0ludGVnZXJTdHJpbmcgfSBmcm9tICdAL2hlbHBlcnMnXG5pbXBvcnQgdHlwZSB7XG4gIEJuQ29uZmlnLFxuICBCbkNvbmZpZ0xpa2UsXG4gIEJuRm9ybWF0Q29uZmlnLFxuICBCbkdsb2JhbENvbmZpZyxcbiAgQm5MaWtlLFxufSBmcm9tICdAL3R5cGVzJ1xuXG5pbXBvcnQgeyBhc3NlcnREZWNpbWFscywgYXNzZXJ0RGVjaW1hbHNJbnRlZ2VyIH0gZnJvbSAnLi9hc3NlcnRpb25zJ1xuaW1wb3J0IHsgZ2V0VGVucywgdG9EZWNpbWFscyB9IGZyb20gJy4vZGVjaW1hbHMnXG5pbXBvcnQgeyBmb3JtYXQgYXMgX2Zvcm1hdCB9IGZyb20gJy4vZm9ybWF0J1xuaW1wb3J0IHsgcGFyc2VDb25maWcsIHBhcnNlTnVtYmVyU3RyaW5nIH0gZnJvbSAnLi9wYXJzZXJzJ1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tICcuL3JvdW5kJ1xuXG5sZXQgZ2xvYmFsQ29uZmlnOiBCbkdsb2JhbENvbmZpZyA9IHtcbiAgcHJlY2lzaW9uOiBERUZBVUxUX0JOX1BSRUNJU0lPTixcbiAgcm91bmRpbmc6IEJOX1JPVU5ESU5HLkRFRkFVTFQsXG4gIGRlY2ltYWxzOiBERUNJTUFMUy5XRUksXG4gIGZvcm1hdDoge1xuICAgIHByZWZpeDogJycsXG4gICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxuICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXG4gICAgZ3JvdXBTaXplOiAzLFxuICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICcgJyxcbiAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcbiAgICBzdWZmaXg6ICcnLFxuICB9LFxufVxuXG5leHBvcnQgY2xhc3MgQk4ge1xuICAvKipcbiAgICogU29saWRpdHkgbWF4aW11bSB1aW50MjU2IHZhbHVlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgTUFYX1VJTlQyNTYoKSB7XG4gICAgcmV0dXJuIEJOLmZyb21CaWdJbnQoMm4gKiogMjU2biAtIDFuLCAxKVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXQgV0VJX0RFQ0lNQUxTKCkge1xuICAgIHJldHVybiBERUNJTUFMUy5XRUlcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IFJPVU5ESU5HKCkge1xuICAgIHJldHVybiBCTl9ST1VORElOR1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBCTn0gY2xhc3MgZ2xvYmFsIGNvbmZpZy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IGNvbmZpZygpOiBCbkdsb2JhbENvbmZpZyB7XG4gICAgcmV0dXJuIGdsb2JhbENvbmZpZ1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBCTn0gY2xhc3MgZ2xvYmFsIHByZWNpc2lvbi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IHByZWNpc2lvbigpOiBudW1iZXIge1xuICAgIHJldHVybiBnbG9iYWxDb25maWcucHJlY2lzaW9uXG4gIH1cblxuICAvKipcbiAgICogUmF3IHZhbHVlIG11bHRpcGxpZWQgYnkgdGVuIHBvd2VyIG9mIHtAbGluayBCTi5wcmVjaXNpb259LlxuICAgKi9cbiAgcmVhZG9ubHkgI3JhdzogYmlnaW50XG5cbiAgLyoqXG4gICAqIHtAbGluayBCTn0gaW5zdGFuY2UgY29uZmlnLlxuICAgKi9cbiAgcmVhZG9ubHkgI2NmZzogQm5Db25maWdcblxuICAvKipcbiAgICogVGVuIHBvd2VyIG9mIHtAbGluayBCTi5wcmVjaXNpb259LlxuICAgKi9cbiAgcmVhZG9ubHkgI3RlbnM6IGJpZ2ludCA9IGdldFRlbnMoQk4ucHJlY2lzaW9uKVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgLSBBbHdheXMgQmlnSW50ICogdGVuIHBvd2VyIG9mIHtAbGluayBCTi5wcmVjaXNpb259XG4gICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlnIG9mIHRoZSB2YWx1ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IGluc3RhbmNlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHZhbHVlOiBiaWdpbnQsIGNvbmZpZzogQm5Db25maWcpIHtcbiAgICB0aGlzLiNyYXcgPSB2YWx1ZVxuICAgIHRoaXMuI2NmZyA9IGNvbmZpZ1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgbmV3IHtAbGluayBCbkdsb2JhbENvbmZpZ30gY29uZmlnIHRvIHRoZSB7QGxpbmsgQk59LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzZXRDb25maWcoY29uZmlnOiBQYXJ0aWFsPEJuR2xvYmFsQ29uZmlnPik6IHZvaWQge1xuICAgIGdsb2JhbENvbmZpZyA9IHsgLi4uZ2xvYmFsQ29uZmlnLCAuLi5jb25maWcgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiBgYXJnYCBpcyB7QGxpbmsgQk59IGluc3RhbmNlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBpc0JuKGFyZzogdW5rbm93bik6IGFyZyBpcyBCTiB7XG4gICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIEJOXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEJOfSBpZiBgdmFsdWVgIGFyZ3VtZW50IGlzIHZhbGlkIGJpZyBpbnQgbGlrZSB2YWx1ZSxcbiAgICogb3RoZXJ3aXNlIHRocm93cyB7QGxpbmsgUnVudGltZUVycm9yfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3Qgb25lRXRoID0gQk4uZnJvbUJpZ0ludCgnMTAwMDAwMDAwMDAwMDAwMDAwMCcsIDE4KVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUJpZ0ludCh2YWx1ZTogQm5MaWtlLCBkZWNpbWFsc09yQ29uZmlnPzogQm5Db25maWdMaWtlKTogQk4ge1xuICAgIGxldCB2YWwgPSB2YWx1ZVxuXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWwgPSBpc0hleCh2YWwpID8gQmlnSW50KHZhbCkudG9TdHJpbmcoKSA6IHZhbFxuICAgICAgYXNzZXJ0KGlzSW50ZWdlclN0cmluZyh2YWwpLCAnSW52YWxpZCBiaWcgaW50IHN0cmluZycpXG4gICAgfVxuICAgIGNvbnN0IGNmZyA9IHBhcnNlQ29uZmlnKGRlY2ltYWxzT3JDb25maWcgPz8gQk4uY29uZmlnLmRlY2ltYWxzKVxuICAgIGNvbnN0IHBhcnNlZCA9IEJpZ0ludChCTi5pc0JuKHZhbCkgPyB2YWwudmFsdWUgOiB2YWwpXG4gICAgY29uc3Qgd2l0aFByZWNpc2lvbiA9IHBhcnNlZCAqIGdldFRlbnMoQk4ucHJlY2lzaW9uIC0gY2ZnLmRlY2ltYWxzKVxuICAgIHJldHVybiBuZXcgQk4od2l0aFByZWNpc2lvbiwgY2ZnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBCTn0gaWYgYHZhbHVlYCBhcmd1bWVudCBpcyB2YWxpZCBpbnRlZ2VyIG9yIGZsb2F0IHZhbHVlLFxuICAgKiBvdGhlcndpc2UgdGhyb3dzIHtAbGluayBSdW50aW1lRXJyb3J9LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBvbmVFdGggPSBCTi5mcm9tUmF3KDEsIDE4KVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVJhdyhcbiAgICB2YWx1ZTogRXhjbHVkZTxCbkxpa2UsIEJOPixcbiAgICBkZWNpbWFsc09yQ29uZmlnPzogQm5Db25maWdMaWtlLFxuICApOiBCTiB7XG4gICAgY29uc3QgdmFsID0gU3RyaW5nKHZhbHVlKVxuICAgIGNvbnN0IGNmZyA9IHBhcnNlQ29uZmlnKGRlY2ltYWxzT3JDb25maWcgPz8gQk4uY29uZmlnLmRlY2ltYWxzKVxuICAgIHJldHVybiBuZXcgQk4oQmlnSW50KHBhcnNlTnVtYmVyU3RyaW5nKHZhbCkpLCBjZmcpXG4gIH1cblxuICAvKipcbiAgICogIEByZXR1cm5zIEEgbWluaW11bSB7QGxpbmsgQk59IHZhbHVlIGZyb20gdGhlIGBhcmdzYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWluKC4uLmFyZ3M6IEJOW10pOiBCTiB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKChtaW4sIGVsKSA9PiAoZWwucmF3IDwgbWluLnJhdyA/IGVsIDogbWluKSlcbiAgfVxuXG4gIC8qKlxuICAgKiAgQHJldHVybnMgQSBtYXhpbXVtIHtAbGluayBCTn0gdmFsdWUgZnJvbSB0aGUgYGFyZ3NgLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYXgoLi4uYXJnczogQk5bXSk6IEJOIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2UoKG1pbiwgZWwpID0+IChlbC5yYXcgPiBtaW4ucmF3ID8gZWwgOiBtaW4pKVxuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBBIGB0aGlzYCBjb25maWcuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNvbmZpZygpOiBCbkNvbmZpZyB7XG4gICAgcmV0dXJuIHRoaXMuI2NmZ1xuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gICAqL1xuICBwdWJsaWMgZ2V0IGRlY2ltYWxzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuI2NmZy5kZWNpbWFsc1xuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB0aGlzYCB2YWx1ZSBpcyB6ZXJvLlxuICAgKi9cbiAgcHVibGljIGdldCBpc1plcm8oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuI3JhdyA9PT0gMG5cbiAgfVxuXG4gIC8qKlxuICAgKiAgQHJldHVybnMgYHRydWVgIGlmIHRoZSBgdGhpc2AgdmFsdWUgaXMgcG9zaXRpdmUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzUG9zaXRpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuI3JhdyA+IDBuXG4gIH1cblxuICAvKipcbiAgICogIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHRoaXNgIHZhbHVlIGlzIG5lZ2F0aXZlLlxuICAgKi9cbiAgcHVibGljIGdldCBpc05lZ2F0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLiNyYXcgPCAwblxuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBBIHJhdyB7QGxpbmsgQmlnSW50fSB2YWx1ZSB3aXRoIHRoZSB7QGxpbmsgQk4ucHJlY2lzaW9ufSBhcHBsaWVkLlxuICAgKi9cbiAgcHVibGljIGdldCByYXcoKTogYmlnaW50IHtcbiAgICByZXR1cm4gdGhpcy4jcmF3XG4gIH1cblxuICAvKipcbiAgICogIEByZXR1cm5zIEEgYmlnIGludCBzdHJpbmcgdmFsdWUgd2l0aCB0aGUgYHRoaXMuZGVjaW1hbHNgIGFwcGxpZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHZhbHVlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRvRGVjaW1hbHModGhpcy4jcmF3LCBCTi5wcmVjaXNpb24sIHRoaXMuI2NmZy5kZWNpbWFscykudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdpdGggdGhlIHJlc3VsdCBvZiB0aGlzIGFkZGVkIHRvIGBvdGhlcmAuXG4gICAqL1xuICBwdWJsaWMgYWRkKG90aGVyOiBCTik6IEJOIHtcbiAgICByZXR1cm4gbmV3IEJOKHRoaXMuI3JhdyArIG90aGVyLnJhdywgdGhpcy4jY2ZnKVxuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdpdGggdGhlIHJlc3VsdCBvZiBvdGhlciBzdWJ0cmFjdGVkIGZyb20gdGhpcy5cbiAgICovXG4gIHB1YmxpYyBzdWIob3RoZXI6IEJOKTogQk4ge1xuICAgIHJldHVybiBuZXcgQk4odGhpcy4jcmF3IC0gb3RoZXIucmF3LCB0aGlzLiNjZmcpXG4gIH1cblxuICAvKipcbiAgICogIEByZXR1cm5zIEEgbmV3IHtAbGluayBCTn0gd2l0aCB0aGUgcmVzdWx0IG9mIHRoaXMgZGl2aWRlZCBieSBgb3RoZXJgLlxuICAgKi9cbiAgcHVibGljIGRpdihvdGhlcjogQk4pOiBCTiB7XG4gICAgYXNzZXJ0KG90aGVyLnJhdyAhPT0gMG4sICdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKVxuICAgIHJldHVybiBuZXcgQk4oKHRoaXMuI3JhdyAqIHRoaXMuI3RlbnMpIC8gb3RoZXIucmF3LCB0aGlzLiNjZmcpXG4gIH1cblxuICAvKipcbiAgICogIEByZXR1cm5zIEEgbmV3IHtAbGluayBCTn0gd2l0aCB0aGUgcmVzdWx0IG9mIHRoaXMgbXVsdGlwbGllZCBieSBgb3RoZXJgLlxuICAgKi9cbiAgcHVibGljIG11bChvdGhlcjogQk4pOiBCTiB7XG4gICAgcmV0dXJuIG5ldyBCTigodGhpcy4jcmF3ICogb3RoZXIucmF3KSAvIHRoaXMuI3RlbnMsIHRoaXMuI2NmZylcbiAgfVxuXG4gIC8qKlxuICAgKiAgQHJldHVybnMgQSBjb21wYXJpc29uIHJlc3VsdCBiZXR3ZWVuIHRoaXMgYW5kIG90aGVyLlxuICAgKi9cbiAgcHVibGljIGNtcChvdGhlcjogQk4pOiBudW1iZXIge1xuICAgIGNvbnN0IGEgPSB0aGlzLiNyYXdcbiAgICBjb25zdCBiID0gb3RoZXIucmF3XG4gICAgaWYgKGEgPCBiKSByZXR1cm4gLTFcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8qKlxuICAgKiAgQHJldHVybnMgYHRydWVgIGlmIGBvdGhlcmAgaXMgZXF1YWwgdG8gYHRoaXNgLlxuICAgKi9cbiAgcHVibGljIGVxKG90aGVyOiBCTik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNtcChvdGhlcikgPT09IDBcbiAgfVxuXG4gIC8qKlxuICAgKiAgQHJldHVybnMgYHRydWVgIGlmIGBvdGhlcmAgaXMgbGVzcyB0aGFuIHRvIGB0aGlzYC5cbiAgICovXG4gIHB1YmxpYyBsdChvdGhlcjogQk4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jbXAob3RoZXIpIDwgMFxuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBgdHJ1ZWAgaWYgYG90aGVyYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHRoaXNgLlxuICAgKi9cbiAgcHVibGljIGx0ZShvdGhlcjogQk4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jbXAob3RoZXIpIDw9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiAgQHJldHVybnMgYHRydWVgIGlmIGBvdGhlcmAgaXMgZ3JlYXRlciB0aGFuIHRvIGB0aGlzYC5cbiAgICovXG4gIHB1YmxpYyBndChvdGhlcjogQk4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jbXAob3RoZXIpID4gMFxuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBgdHJ1ZWAgaWYgYG90aGVyYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHRoaXNgLlxuICAgKi9cbiAgcHVibGljIGd0ZShvdGhlcjogQk4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jbXAob3RoZXIpID49IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiBgdGhpc2AuXG4gICAqIEB0aHJvd3Mge0BsaW5rIFJ1bnRpbWVFcnJvcn0gaWYgYEJOLnByZWNpc2lvbmAgaXMgbm90IGV2ZW4gbnVtYmVyLlxuICAgKi9cbiAgcHVibGljIHNxcnQoKTogQk4ge1xuICAgIGFzc2VydCghdGhpcy5pc05lZ2F0aXZlLCAnc3FydCBvZiBuZWdhdGl2ZSBudW1iZXJzIGlzIG5vdCBzdXBwb3J0ZWQnKVxuXG4gICAgaWYgKHRoaXMuaXNaZXJvKSByZXR1cm4gdGhpc1xuXG4gICAgY29uc3QgYmFzZSA9IHRoaXMucmF3ICogdGhpcy4jdGVuc1xuICAgIGxldCB4MCA9IGJhc2UgLyAyblxuICAgIGxldCB4MSA9ICh4MCArIGJhc2UgLyB4MCkgLyAyblxuXG4gICAgd2hpbGUgKHgwIC0geDEgPiAxbikge1xuICAgICAgeDAgPSB4MVxuICAgICAgeDEgPSAoeDAgKyBiYXNlIC8geDApIC8gMm5cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJOKHgxLCB0aGlzLiNjZmcpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEJOfSB3aG9zZSB2YWx1ZSBpcyBuZWdhdGVkIGB0aGlzYCAobXVsdGlwbGllZCBieSAtMSkuXG4gICAqL1xuICBwdWJsaWMgbmVnYXRlZCgpOiBCTiB7XG4gICAgcmV0dXJuIG5ldyBCTih0aGlzLiNyYXcgKiAtMW4sIHRoaXMuI2NmZylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdob3NlIHZhbHVlIGlzIGFic29sdXRlIGB0aGlzYC5cbiAgICovXG4gIHB1YmxpYyBhYnMoKTogQk4ge1xuICAgIHJldHVybiB0aGlzLmlzUG9zaXRpdmUgPyB0aGlzIDogdGhpcy5uZWdhdGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdob3NlIHZhbHVlIGlzIGB0aGlzYCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mIGBleHBvbmVudGAuXG4gICAqL1xuICBwdWJsaWMgcG93KGV4cG9uZW50OiBudW1iZXIpOiBCTiB7XG4gICAgYXNzZXJ0RGVjaW1hbHNJbnRlZ2VyKGV4cG9uZW50KVxuICAgIGNvbnN0IGV4cCA9IEJpZ0ludChleHBvbmVudClcbiAgICBjb25zdCBmciA9IGdldFRlbnMoTnVtYmVyKEJpZ0ludChCTi5wcmVjaXNpb24pICogKGV4cCAtIDFuKSkpXG4gICAgcmV0dXJuIG5ldyBCTih0aGlzLiNyYXcgKiogZXhwIC8gZnIsIHRoaXMuI2NmZylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdob3NlIHZhbHVlIGlzIHBlcmNlbnRhZ2Ugb2YgYHRoaXNgIHZhbHVlLlxuICAgKi9cbiAgcHVibGljIHBlcmNlbnQocGVyY2VudDogbnVtYmVyKTogQk4ge1xuICAgIHJldHVybiB0aGlzLm11bCh0aGlzLiNwZXJjZW50VG9GcmFjdGlvbihwZXJjZW50KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdob3NlIHZhbHVlIGlzIGB0aGlzYCB3aXRoIGFkZGVkIHBlcmNlbnRhZ2UuXG4gICAqL1xuICBwdWJsaWMgYWRkUGVyY2VudChwZXJjZW50OiBudW1iZXIpOiBCTiB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMuI29uZS5hZGQodGhpcy4jcGVyY2VudFRvRnJhY3Rpb24ocGVyY2VudCkpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBCTn0gd2hvc2UgdmFsdWUgaXMgYHRoaXNgIHdpdGggc3VidHJhY3RlZCBwZXJjZW50YWdlLlxuICAgKi9cbiAgcHVibGljIHN1YlBlcmNlbnQocGVyY2VudDogbnVtYmVyKTogQk4ge1xuICAgIHJldHVybiB0aGlzLmRpdih0aGlzLiNvbmUuYWRkKHRoaXMuI3BlcmNlbnRUb0ZyYWN0aW9uKHBlcmNlbnQpKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdpdGggdGhlIHByb3ZpZGVkIGRlY2ltYWxzLlxuICAgKi9cbiAgcHVibGljIHRvRGVjaW1hbHMoZGVjaW1hbHM6IG51bWJlcik6IEJOIHtcbiAgICBpZiAoZGVjaW1hbHMgPT09IHRoaXMuI2NmZy5kZWNpbWFscykgcmV0dXJuIHRoaXNcblxuICAgIHJldHVybiBkZWNpbWFscyA+IHRoaXMuI2NmZy5kZWNpbWFsc1xuICAgICAgPyB0aGlzLnRvR3JlYXRlckRlY2ltYWxzKGRlY2ltYWxzKVxuICAgICAgOiB0aGlzLnRvTGVzc0RlY2ltYWxzKGRlY2ltYWxzKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBCTn0gd2l0aCB0aGUgcHJvdmlkZWQgZGVjaW1hbHMsIGxlc3MgdGhhbiBjdXJyZW50IG9uZSxcbiAgICogb3RoZXJ3aXNlIHRocm93cyB7QGxpbmsgUnVudGltZUVycm9yfS5cbiAgICovXG4gIHB1YmxpYyB0b0xlc3NEZWNpbWFscyhkZWNpbWFsczogbnVtYmVyKTogQk4ge1xuICAgIGFzc2VydERlY2ltYWxzKHRoaXMuI2NmZy5kZWNpbWFscywgZGVjaW1hbHMsIEJOX0FTU0VSVF9ERUNJTUFMU19PUC5MRVNTKVxuICAgIHJldHVybiB0aGlzLiN0b0RlY2ltYWxzKGRlY2ltYWxzKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBCTn0gd2l0aCB0aGUgcHJvdmlkZWQgZGVjaW1hbHMsIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9uZSxcbiAgICogb3RoZXJ3aXNlIHRocm93cyB7QGxpbmsgUnVudGltZUVycm9yfS5cbiAgICovXG4gIHB1YmxpYyB0b0dyZWF0ZXJEZWNpbWFscyhkZWNpbWFsczogbnVtYmVyKTogQk4ge1xuICAgIGFzc2VydERlY2ltYWxzKHRoaXMuI2NmZy5kZWNpbWFscywgZGVjaW1hbHMsIEJOX0FTU0VSVF9ERUNJTUFMU19PUC5HUkVBVEVSKVxuICAgIHJldHVybiB0aGlzLiN0b0RlY2ltYWxzKGRlY2ltYWxzKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgYHRoaXNgIGZpeGVkLXBvaW50IG5vdGF0aW9uIGFuZFxuICAgKiBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB7QGxpbmsgQk4uY29uZmlnLmZvcm1hdH0gYW5kXG4gICAqIGBmb3JtYXRgIChpZiBleGlzdCkgb2JqZWN0cy5cbiAgICovXG4gIHB1YmxpYyBmb3JtYXQoZm9ybWF0OiBCbkZvcm1hdENvbmZpZyA9IHt9KTogc3RyaW5nIHtcbiAgICByZXR1cm4gX2Zvcm1hdCh0aGlzLnRvU3RyaW5nKCksIHsgLi4uQk4uY29uZmlnLmZvcm1hdCwgLi4uZm9ybWF0IH0pXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEJOfSB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgYHRoaXNgIHJvdW5kZWQgdG9cbiAgICogZGVjaW1hbHMgdXNpbmcge0BsaW5rIEJOX1JPVU5ESU5HfSByb3VuZGluZyBtb2RlLlxuICAgKi9cbiAgcHVibGljIHJvdW5kKGRlY2ltYWxzOiBudW1iZXIsIHJvdW5kaW5nPzogQk5fUk9VTkRJTkcpOiBCTiB7XG4gICAgcmV0dXJuIEJOLmZyb21CaWdJbnQoXG4gICAgICByb3VuZCh0aGlzLCBkZWNpbWFscywgcm91bmRpbmcgPz8gQk4uY29uZmlnLnJvdW5kaW5nKSxcbiAgICAgIHsgLi4udGhpcy4jY2ZnLCBkZWNpbWFscyB9LFxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIGh1bWFuLXJlYWRhYmxlIGZsb2F0IHN0cmluZy5cbiAgICovXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIGxldCB2YWwgPSB0aGlzLnZhbHVlXG5cbiAgICBjb25zdCBkZWNpbWFscyA9IHRoaXMuI2NmZy5kZWNpbWFsc1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gdGhpcy5pc05lZ2F0aXZlID8gJy0nIDogJydcbiAgICBjb25zdCBpc0xlc3NPbmUgPSB2YWwubGVuZ3RoIDwgZGVjaW1hbHNcblxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUpIHZhbCA9IHZhbC5zbGljZSgxKVxuXG4gICAgaWYgKGlzTGVzc09uZSkgdmFsID0gdmFsLnBhZFN0YXJ0KGRlY2ltYWxzLCAnMCcpXG5cbiAgICBjb25zdCBwb2ludElkeCA9IHZhbC5sZW5ndGggLSBkZWNpbWFsc1xuXG4gICAgdmFsID0gdmFsLnNsaWNlKDAsIHBvaW50SWR4KSArICcuJyArIHZhbC5zbGljZShwb2ludElkeClcblxuICAgIGlmICh2YWwuc3RhcnRzV2l0aCgnLicpKSB2YWwgPSAnMCcgKyB2YWxcblxuICAgIHJldHVybiBuZWdhdGl2ZSArIHZhbFxuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9KU09OL3N0cmluZ2lmeSNkZXNjcmlwdGlvbn1cbiAgICovXG4gIHB1YmxpYyB0b0pTT04oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgZ2V0ICNvbmUoKTogQk4ge1xuICAgIHJldHVybiBCTi5mcm9tUmF3KDEsIHRoaXMuI2NmZylcbiAgfVxuXG4gIGdldCAjaHVuZHJlZCgpOiBCTiB7XG4gICAgcmV0dXJuIEJOLmZyb21SYXcoMTAwLCB0aGlzLiNjZmcpXG4gIH1cblxuICAjdG9EZWNpbWFscyhkZWNpbWFsczogbnVtYmVyKTogQk4ge1xuICAgIHJldHVybiBuZXcgQk4odGhpcy4jcmF3LCB7IC4uLnRoaXMuI2NmZywgZGVjaW1hbHMgfSlcbiAgfVxuXG4gICNwZXJjZW50VG9GcmFjdGlvbihwZXJjZW50OiBudW1iZXIpOiBCTiB7XG4gICAgcmV0dXJuIEJOLmZyb21SYXcocGVyY2VudCwgdGhpcy4jY2ZnKS5kaXYodGhpcy4jaHVuZHJlZClcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkRFRkFVTFRfQk5fUFJFQ0lTSU9OIiwiQk5fQVNTRVJUX0RFQ0lNQUxTX09QIiwiQk5fUk9VTkRJTkciLCJERUNJTUFMUyIsImFzc2VydCIsImlzSGV4IiwiaXNJbnRlZ2VyU3RyaW5nIiwiYXNzZXJ0RGVjaW1hbHMiLCJhc3NlcnREZWNpbWFsc0ludGVnZXIiLCJnZXRUZW5zIiwidG9EZWNpbWFscyIsImZvcm1hdCIsIl9mb3JtYXQiLCJwYXJzZUNvbmZpZyIsInBhcnNlTnVtYmVyU3RyaW5nIiwicm91bmQiLCJnbG9iYWxDb25maWciLCJwcmVjaXNpb24iLCJyb3VuZGluZyIsIkRFRkFVTFQiLCJkZWNpbWFscyIsIldFSSIsInByZWZpeCIsImRlY2ltYWxTZXBhcmF0b3IiLCJncm91cFNlcGFyYXRvciIsImdyb3VwU2l6ZSIsImZyYWN0aW9uR3JvdXBTZXBhcmF0b3IiLCJmcmFjdGlvbkdyb3VwU2l6ZSIsInN1ZmZpeCIsIkJOIiwiTUFYX1VJTlQyNTYiLCJmcm9tQmlnSW50IiwiV0VJX0RFQ0lNQUxTIiwiUk9VTkRJTkciLCJjb25maWciLCJzZXRDb25maWciLCJpc0JuIiwiYXJnIiwidmFsdWUiLCJkZWNpbWFsc09yQ29uZmlnIiwidmFsIiwiQmlnSW50IiwidG9TdHJpbmciLCJjZmciLCJwYXJzZWQiLCJ3aXRoUHJlY2lzaW9uIiwiZnJvbVJhdyIsIlN0cmluZyIsIm1pbiIsImFyZ3MiLCJyZWR1Y2UiLCJlbCIsInJhdyIsIm1heCIsImlzWmVybyIsImlzUG9zaXRpdmUiLCJpc05lZ2F0aXZlIiwiYWRkIiwib3RoZXIiLCJzdWIiLCJkaXYiLCJ0ZW5zIiwibXVsIiwiY21wIiwiYSIsImIiLCJlcSIsImx0IiwibHRlIiwiZ3QiLCJndGUiLCJzcXJ0IiwiYmFzZSIsIngwIiwieDEiLCJuZWdhdGVkIiwiYWJzIiwicG93IiwiZXhwb25lbnQiLCJleHAiLCJmciIsIk51bWJlciIsInBlcmNlbnQiLCJwZXJjZW50VG9GcmFjdGlvbiIsImFkZFBlcmNlbnQiLCJvbmUiLCJzdWJQZXJjZW50IiwidG9HcmVhdGVyRGVjaW1hbHMiLCJ0b0xlc3NEZWNpbWFscyIsIkxFU1MiLCJHUkVBVEVSIiwibmVnYXRpdmUiLCJpc0xlc3NPbmUiLCJsZW5ndGgiLCJzbGljZSIsInBhZFN0YXJ0IiwicG9pbnRJZHgiLCJzdGFydHNXaXRoIiwidG9KU09OIiwiaHVuZHJlZCJdLCJyYW5nZU1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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