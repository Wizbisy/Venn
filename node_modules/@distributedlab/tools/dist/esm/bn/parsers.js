import { NUMBER_REGEX } from "../const";
import { assert, isFixedPointString } from "../helpers";
import { assertDecimalsInteger } from "./assertions";
import { BN } from "./bn";
export const parseNumberString = (_value)=>{
    let val = _value.trim();
    assert(isFixedPointString(val), 'Invalid fixed point string value');
    while(val.length !== 1 && val[0] === '0' && val[1] !== '.'){
        val = val.substring(1);
    }
    const match = val.match(NUMBER_REGEX);
    const sign = match[1];
    const whole = sign + match[2];
    var _match_;
    const fractional = ((_match_ = match[3]) !== null && _match_ !== void 0 ? _match_ : '').replace('.', '').slice(0, BN.precision);
    const isFractionalZero = !fractional || fractional.match(/^(0+)$/);
    const isWholeZero = whole === '0' || whole.replaceAll('0', '') === '';
    const exponential = match[4];
    const exponentialSign = exponential === null || exponential === void 0 ? void 0 : exponential.slice(1, 2);
    const exponentialDecimals = Number(exponential === null || exponential === void 0 ? void 0 : exponential.slice(2));
    if (isWholeZero && isFractionalZero) return '0';
    let result = whole.padEnd(whole.length + BN.precision, '0');
    if (!fractional) return fromExp(result, exponentialSign, exponentialDecimals);
    result = (isWholeZero ? '' : whole) + fractional.padEnd(BN.precision, '0');
    return fromExp(result, exponentialSign, exponentialDecimals);
};
const fromExp = (value, sign, decimals)=>{
    if (!sign || !decimals) return value;
    if (sign === '+') return value.padEnd(value.length + decimals, '0');
    if (decimals > value.length) return '0';
    return value.slice(0, value.length - decimals);
};
export const parseConfig = (config)=>{
    const cfg = typeof config === 'number' ? {
        decimals: config
    } : config;
    assertDecimalsInteger(cfg.decimals);
    assert(Boolean(cfg.decimals), 'Decimals cannot be zero or undefined');
    assert(cfg.decimals > 0, 'Decimals cannot be negative');
    return cfg;
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ibi9wYXJzZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5VTUJFUl9SRUdFWCB9IGZyb20gJ0AvY29uc3QnXG5pbXBvcnQgeyBhc3NlcnQsIGlzRml4ZWRQb2ludFN0cmluZyB9IGZyb20gJ0AvaGVscGVycydcbmltcG9ydCB0eXBlIHsgQm5Db25maWcsIEJuQ29uZmlnTGlrZSB9IGZyb20gJ0AvdHlwZXMnXG5cbmltcG9ydCB7IGFzc2VydERlY2ltYWxzSW50ZWdlciB9IGZyb20gJy4vYXNzZXJ0aW9ucydcbmltcG9ydCB7IEJOIH0gZnJvbSAnLi9ibidcblxuZXhwb3J0IGNvbnN0IHBhcnNlTnVtYmVyU3RyaW5nID0gKF92YWx1ZTogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgbGV0IHZhbCA9IF92YWx1ZS50cmltKClcblxuICBhc3NlcnQoaXNGaXhlZFBvaW50U3RyaW5nKHZhbCksICdJbnZhbGlkIGZpeGVkIHBvaW50IHN0cmluZyB2YWx1ZScpXG5cbiAgd2hpbGUgKHZhbC5sZW5ndGggIT09IDEgJiYgdmFsWzBdID09PSAnMCcgJiYgdmFsWzFdICE9PSAnLicpIHtcbiAgICB2YWwgPSB2YWwuc3Vic3RyaW5nKDEpXG4gIH1cblxuICBjb25zdCBtYXRjaCA9IHZhbC5tYXRjaChOVU1CRVJfUkVHRVgpIVxuICBjb25zdCBzaWduID0gbWF0Y2hbMV1cbiAgY29uc3Qgd2hvbGUgPSBzaWduICsgbWF0Y2hbMl1cbiAgY29uc3QgZnJhY3Rpb25hbCA9IChtYXRjaFszXSA/PyAnJykucmVwbGFjZSgnLicsICcnKS5zbGljZSgwLCBCTi5wcmVjaXNpb24pXG4gIGNvbnN0IGlzRnJhY3Rpb25hbFplcm8gPSAhZnJhY3Rpb25hbCB8fCBmcmFjdGlvbmFsLm1hdGNoKC9eKDArKSQvKVxuICBjb25zdCBpc1dob2xlWmVybyA9IHdob2xlID09PSAnMCcgfHwgd2hvbGUucmVwbGFjZUFsbCgnMCcsICcnKSA9PT0gJydcblxuICBjb25zdCBleHBvbmVudGlhbCA9IG1hdGNoWzRdXG4gIGNvbnN0IGV4cG9uZW50aWFsU2lnbiA9IGV4cG9uZW50aWFsPy5zbGljZSgxLCAyKVxuICBjb25zdCBleHBvbmVudGlhbERlY2ltYWxzID0gTnVtYmVyKGV4cG9uZW50aWFsPy5zbGljZSgyKSlcblxuICBpZiAoaXNXaG9sZVplcm8gJiYgaXNGcmFjdGlvbmFsWmVybykgcmV0dXJuICcwJ1xuXG4gIGxldCByZXN1bHQgPSB3aG9sZS5wYWRFbmQod2hvbGUubGVuZ3RoICsgQk4ucHJlY2lzaW9uLCAnMCcpXG5cbiAgaWYgKCFmcmFjdGlvbmFsKSByZXR1cm4gZnJvbUV4cChyZXN1bHQsIGV4cG9uZW50aWFsU2lnbiwgZXhwb25lbnRpYWxEZWNpbWFscylcblxuICByZXN1bHQgPSAoaXNXaG9sZVplcm8gPyAnJyA6IHdob2xlKSArIGZyYWN0aW9uYWwucGFkRW5kKEJOLnByZWNpc2lvbiwgJzAnKVxuXG4gIHJldHVybiBmcm9tRXhwKHJlc3VsdCwgZXhwb25lbnRpYWxTaWduLCBleHBvbmVudGlhbERlY2ltYWxzKVxufVxuXG5jb25zdCBmcm9tRXhwID0gKHZhbHVlOiBzdHJpbmcsIHNpZ24/OiBzdHJpbmcsIGRlY2ltYWxzPzogbnVtYmVyKSA9PiB7XG4gIGlmICghc2lnbiB8fCAhZGVjaW1hbHMpIHJldHVybiB2YWx1ZVxuICBpZiAoc2lnbiA9PT0gJysnKSByZXR1cm4gdmFsdWUucGFkRW5kKHZhbHVlLmxlbmd0aCArIGRlY2ltYWxzLCAnMCcpXG4gIGlmIChkZWNpbWFscyA+IHZhbHVlLmxlbmd0aCkgcmV0dXJuICcwJ1xuXG4gIHJldHVybiB2YWx1ZS5zbGljZSgwLCB2YWx1ZS5sZW5ndGggLSBkZWNpbWFscylcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlQ29uZmlnID0gKGNvbmZpZzogQm5Db25maWdMaWtlKTogQm5Db25maWcgPT4ge1xuICBjb25zdCBjZmcgPSB0eXBlb2YgY29uZmlnID09PSAnbnVtYmVyJyA/IHsgZGVjaW1hbHM6IGNvbmZpZyB9IDogY29uZmlnXG4gIGFzc2VydERlY2ltYWxzSW50ZWdlcihjZmcuZGVjaW1hbHMpXG4gIGFzc2VydChCb29sZWFuKGNmZy5kZWNpbWFscyksICdEZWNpbWFscyBjYW5ub3QgYmUgemVybyBvciB1bmRlZmluZWQnKVxuICBhc3NlcnQoY2ZnLmRlY2ltYWxzID4gMCwgJ0RlY2ltYWxzIGNhbm5vdCBiZSBuZWdhdGl2ZScpXG4gIHJldHVybiBjZmdcbn1cbiJdLCJuYW1lcyI6WyJOVU1CRVJfUkVHRVgiLCJhc3NlcnQiLCJpc0ZpeGVkUG9pbnRTdHJpbmciLCJhc3NlcnREZWNpbWFsc0ludGVnZXIiLCJCTiIsInBhcnNlTnVtYmVyU3RyaW5nIiwiX3ZhbHVlIiwidmFsIiwidHJpbSIsImxlbmd0aCIsInN1YnN0cmluZyIsIm1hdGNoIiwic2lnbiIsIndob2xlIiwiZnJhY3Rpb25hbCIsInJlcGxhY2UiLCJzbGljZSIsInByZWNpc2lvbiIsImlzRnJhY3Rpb25hbFplcm8iLCJpc1dob2xlWmVybyIsInJlcGxhY2VBbGwiLCJleHBvbmVudGlhbCIsImV4cG9uZW50aWFsU2lnbiIsImV4cG9uZW50aWFsRGVjaW1hbHMiLCJOdW1iZXIiLCJyZXN1bHQiLCJwYWRFbmQiLCJmcm9tRXhwIiwidmFsdWUiLCJkZWNpbWFscyIsInBhcnNlQ29uZmlnIiwiY29uZmlnIiwiY2ZnIiwiQm9vbGVhbiJdLCJyYW5nZU1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxZQUFZLFFBQVEsV0FBUztBQUN0QyxTQUFTQyxNQUFNLEVBQUVDLGtCQUFrQixRQUFRLGFBQVc7QUFHdEQsU0FBU0MscUJBQXFCLFFBQVEsZUFBYztBQUNwRCxTQUFTQyxFQUFFLFFBQVEsT0FBTTtBQUV6QixPQUFPLE1BQU1DLG9CQUFvQixDQUFDQztJQUNoQyxJQUFJQyxNQUFNRCxPQUFPRSxJQUFJO0lBRXJCUCxPQUFPQyxtQkFBbUJLLE1BQU07SUFFaEMsTUFBT0EsSUFBSUUsTUFBTSxLQUFLLEtBQUtGLEdBQUcsQ0FBQyxFQUFFLEtBQUssT0FBT0EsR0FBRyxDQUFDLEVBQUUsS0FBSyxJQUFLO1FBQzNEQSxNQUFNQSxJQUFJRyxTQUFTLENBQUM7SUFDdEI7SUFFQSxNQUFNQyxRQUFRSixJQUFJSSxLQUFLLENBQUNYO0lBQ3hCLE1BQU1ZLE9BQU9ELEtBQUssQ0FBQyxFQUFFO0lBQ3JCLE1BQU1FLFFBQVFELE9BQU9ELEtBQUssQ0FBQyxFQUFFO1FBQ1RBO0lBQXBCLE1BQU1HLGFBQWEsQUFBQ0gsQ0FBQUEsQ0FBQUEsVUFBQUEsS0FBSyxDQUFDLEVBQUUsY0FBUkEscUJBQUFBLFVBQVksRUFBQyxFQUFHSSxPQUFPLENBQUMsS0FBSyxJQUFJQyxLQUFLLENBQUMsR0FBR1osR0FBR2EsU0FBUztJQUMxRSxNQUFNQyxtQkFBbUIsQ0FBQ0osY0FBY0EsV0FBV0gsS0FBSyxDQUFDO0lBQ3pELE1BQU1RLGNBQWNOLFVBQVUsT0FBT0EsTUFBTU8sVUFBVSxDQUFDLEtBQUssUUFBUTtJQUVuRSxNQUFNQyxjQUFjVixLQUFLLENBQUMsRUFBRTtJQUM1QixNQUFNVyxrQkFBa0JELHdCQUFBQSxrQ0FBQUEsWUFBYUwsS0FBSyxDQUFDLEdBQUc7SUFDOUMsTUFBTU8sc0JBQXNCQyxPQUFPSCx3QkFBQUEsa0NBQUFBLFlBQWFMLEtBQUssQ0FBQztJQUV0RCxJQUFJRyxlQUFlRCxrQkFBa0IsT0FBTztJQUU1QyxJQUFJTyxTQUFTWixNQUFNYSxNQUFNLENBQUNiLE1BQU1KLE1BQU0sR0FBR0wsR0FBR2EsU0FBUyxFQUFFO0lBRXZELElBQUksQ0FBQ0gsWUFBWSxPQUFPYSxRQUFRRixRQUFRSCxpQkFBaUJDO0lBRXpERSxTQUFTLEFBQUNOLENBQUFBLGNBQWMsS0FBS04sS0FBSSxJQUFLQyxXQUFXWSxNQUFNLENBQUN0QixHQUFHYSxTQUFTLEVBQUU7SUFFdEUsT0FBT1UsUUFBUUYsUUFBUUgsaUJBQWlCQztBQUMxQyxFQUFDO0FBRUQsTUFBTUksVUFBVSxDQUFDQyxPQUFlaEIsTUFBZWlCO0lBQzdDLElBQUksQ0FBQ2pCLFFBQVEsQ0FBQ2lCLFVBQVUsT0FBT0Q7SUFDL0IsSUFBSWhCLFNBQVMsS0FBSyxPQUFPZ0IsTUFBTUYsTUFBTSxDQUFDRSxNQUFNbkIsTUFBTSxHQUFHb0IsVUFBVTtJQUMvRCxJQUFJQSxXQUFXRCxNQUFNbkIsTUFBTSxFQUFFLE9BQU87SUFFcEMsT0FBT21CLE1BQU1aLEtBQUssQ0FBQyxHQUFHWSxNQUFNbkIsTUFBTSxHQUFHb0I7QUFDdkM7QUFFQSxPQUFPLE1BQU1DLGNBQWMsQ0FBQ0M7SUFDMUIsTUFBTUMsTUFBTSxPQUFPRCxXQUFXLFdBQVc7UUFBRUYsVUFBVUU7SUFBTyxJQUFJQTtJQUNoRTVCLHNCQUFzQjZCLElBQUlILFFBQVE7SUFDbEM1QixPQUFPZ0MsUUFBUUQsSUFBSUgsUUFBUSxHQUFHO0lBQzlCNUIsT0FBTytCLElBQUlILFFBQVEsR0FBRyxHQUFHO0lBQ3pCLE9BQU9HO0FBQ1QsRUFBQyJ9