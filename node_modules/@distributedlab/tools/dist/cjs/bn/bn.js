"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "BN", {
    enumerable: true,
    get: function() {
        return BN;
    }
});
const _const = require("../const");
const _enums = require("../enums");
const _helpers = require("../helpers");
const _assertions = require("./assertions");
const _decimals = require("./decimals");
const _format = require("./format");
const _parsers = require("./parsers");
const _round = require("./round");
function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _class_private_method_get(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
}
function _class_private_method_init(obj, privateSet) {
    _check_private_redeclaration(obj, privateSet);
    privateSet.add(obj);
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
let globalConfig = {
    precision: _const.DEFAULT_BN_PRECISION,
    rounding: _enums.BN_ROUNDING.DEFAULT,
    decimals: _enums.DECIMALS.WEI,
    format: {
        prefix: '',
        decimalSeparator: '.',
        groupSeparator: ',',
        groupSize: 3,
        fractionGroupSeparator: ' ',
        fractionGroupSize: 0,
        suffix: ''
    }
};
var _raw = new WeakMap(), _cfg = new WeakMap(), _tens = new WeakMap(), _one = new WeakMap(), _hundred = new WeakMap(), _toDecimals = new WeakSet(), _percentToFraction = new WeakSet();
let BN = class BN {
    /**
   * Solidity maximum uint256 value.
   */ static get MAX_UINT256() {
        return BN.fromBigInt(2n ** 256n - 1n, 1);
    }
    static get WEI_DECIMALS() {
        return _enums.DECIMALS.WEI;
    }
    static get ROUNDING() {
        return _enums.BN_ROUNDING;
    }
    /**
   * {@link BN} class global config.
   */ static get config() {
        return globalConfig;
    }
    /**
   * {@link BN} class global precision.
   */ static get precision() {
        return globalConfig.precision;
    }
    /**
   * Sets new {@link BnGlobalConfig} config to the {@link BN}.
   */ static setConfig(config) {
        globalConfig = _object_spread({}, globalConfig, config);
    }
    /**
   *
   * @returns `true` if `arg` is {@link BN} instance.
   */ static isBn(arg) {
        return arg instanceof BN;
    }
    /**
   * @returns A new {@link BN} if `value` argument is valid big int like value,
   * otherwise throws {@link RuntimeError}.
   *
   * @example
   * ```ts
   * const oneEth = BN.fromBigInt('1000000000000000000', 18)
   * ```
   */ static fromBigInt(value, decimalsOrConfig) {
        let val = value;
        if (typeof val === 'string') {
            val = (0, _helpers.isHex)(val) ? BigInt(val).toString() : val;
            (0, _helpers.assert)((0, _helpers.isIntegerString)(val), 'Invalid big int string');
        }
        const cfg = (0, _parsers.parseConfig)(decimalsOrConfig !== null && decimalsOrConfig !== void 0 ? decimalsOrConfig : BN.config.decimals);
        const parsed = BigInt(BN.isBn(val) ? val.value : val);
        const withPrecision = parsed * (0, _decimals.getTens)(BN.precision - cfg.decimals);
        return new BN(withPrecision, cfg);
    }
    /**
   * @returns A new {@link BN} if `value` argument is valid integer or float value,
   * otherwise throws {@link RuntimeError}.
   * @example
   * ```ts
   * const oneEth = BN.fromRaw(1, 18)
   * ```
   */ static fromRaw(value, decimalsOrConfig) {
        const val = String(value);
        const cfg = (0, _parsers.parseConfig)(decimalsOrConfig !== null && decimalsOrConfig !== void 0 ? decimalsOrConfig : BN.config.decimals);
        return new BN(BigInt((0, _parsers.parseNumberString)(val)), cfg);
    }
    /**
   *  @returns A minimum {@link BN} value from the `args`.
   */ static min(...args) {
        return args.reduce((min, el)=>el.raw < min.raw ? el : min);
    }
    /**
   *  @returns A maximum {@link BN} value from the `args`.
   */ static max(...args) {
        return args.reduce((min, el)=>el.raw > min.raw ? el : min);
    }
    /**
   *  @returns A `this` config.
   */ get config() {
        return _class_private_field_get(this, _cfg);
    }
    /**
   *  @returns The number of decimal places
   */ get decimals() {
        return _class_private_field_get(this, _cfg).decimals;
    }
    /**
   *  @returns `true` if the `this` value is zero.
   */ get isZero() {
        return _class_private_field_get(this, _raw) === 0n;
    }
    /**
   *  @returns `true` if the `this` value is positive.
   */ get isPositive() {
        return _class_private_field_get(this, _raw) > 0n;
    }
    /**
   *  @returns `true` if the `this` value is negative.
   */ get isNegative() {
        return _class_private_field_get(this, _raw) < 0n;
    }
    /**
   *  @returns A raw {@link BigInt} value with the {@link BN.precision} applied.
   */ get raw() {
        return _class_private_field_get(this, _raw);
    }
    /**
   *  @returns A big int string value with the `this.decimals` applied.
   */ get value() {
        return (0, _decimals.toDecimals)(_class_private_field_get(this, _raw), BN.precision, _class_private_field_get(this, _cfg).decimals).toString();
    }
    /**
   *  @returns A new {@link BN} with the result of this added to `other`.
   */ add(other) {
        return new BN(_class_private_field_get(this, _raw) + other.raw, _class_private_field_get(this, _cfg));
    }
    /**
   *  @returns A new {@link BN} with the result of other subtracted from this.
   */ sub(other) {
        return new BN(_class_private_field_get(this, _raw) - other.raw, _class_private_field_get(this, _cfg));
    }
    /**
   *  @returns A new {@link BN} with the result of this divided by `other`.
   */ div(other) {
        (0, _helpers.assert)(other.raw !== 0n, 'Cannot divide by zero');
        return new BN(_class_private_field_get(this, _raw) * _class_private_field_get(this, _tens) / other.raw, _class_private_field_get(this, _cfg));
    }
    /**
   *  @returns A new {@link BN} with the result of this multiplied by `other`.
   */ mul(other) {
        return new BN(_class_private_field_get(this, _raw) * other.raw / _class_private_field_get(this, _tens), _class_private_field_get(this, _cfg));
    }
    /**
   *  @returns A comparison result between this and other.
   */ cmp(other) {
        const a = _class_private_field_get(this, _raw);
        const b = other.raw;
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
    }
    /**
   *  @returns `true` if `other` is equal to `this`.
   */ eq(other) {
        return this.cmp(other) === 0;
    }
    /**
   *  @returns `true` if `other` is less than to `this`.
   */ lt(other) {
        return this.cmp(other) < 0;
    }
    /**
   *  @returns `true` if `other` is less than or equal to `this`.
   */ lte(other) {
        return this.cmp(other) <= 0;
    }
    /**
   *  @returns `true` if `other` is greater than to `this`.
   */ gt(other) {
        return this.cmp(other) > 0;
    }
    /**
   *  @returns `true` if `other` is greater than or equal to `this`.
   */ gte(other) {
        return this.cmp(other) >= 0;
    }
    /**
   * @returns A new {@link BN} whose value is the square root of `this`.
   * @throws {@link RuntimeError} if `BN.precision` is not even number.
   */ sqrt() {
        (0, _helpers.assert)(!this.isNegative, 'sqrt of negative numbers is not supported');
        if (this.isZero) return this;
        const base = this.raw * _class_private_field_get(this, _tens);
        let x0 = base / 2n;
        let x1 = (x0 + base / x0) / 2n;
        while(x0 - x1 > 1n){
            x0 = x1;
            x1 = (x0 + base / x0) / 2n;
        }
        return new BN(x1, _class_private_field_get(this, _cfg));
    }
    /**
   * @returns A new {@link BN} whose value is negated `this` (multiplied by -1).
   */ negated() {
        return new BN(_class_private_field_get(this, _raw) * -1n, _class_private_field_get(this, _cfg));
    }
    /**
   * @returns A new {@link BN} whose value is absolute `this`.
   */ abs() {
        return this.isPositive ? this : this.negated();
    }
    /**
   * @returns A new {@link BN} whose value is `this` raised to the power of `exponent`.
   */ pow(exponent) {
        (0, _assertions.assertDecimalsInteger)(exponent);
        const exp = BigInt(exponent);
        const fr = (0, _decimals.getTens)(Number(BigInt(BN.precision) * (exp - 1n)));
        return new BN(_class_private_field_get(this, _raw) ** exp / fr, _class_private_field_get(this, _cfg));
    }
    /**
   * @returns A new {@link BN} whose value is percentage of `this` value.
   */ percent(percent) {
        return this.mul(_class_private_method_get(this, _percentToFraction, percentToFraction).call(this, percent));
    }
    /**
   * @returns A new {@link BN} whose value is `this` with added percentage.
   */ addPercent(percent) {
        return this.mul(_class_private_field_get(this, _one).add(_class_private_method_get(this, _percentToFraction, percentToFraction).call(this, percent)));
    }
    /**
   * @returns A new {@link BN} whose value is `this` with subtracted percentage.
   */ subPercent(percent) {
        return this.div(_class_private_field_get(this, _one).add(_class_private_method_get(this, _percentToFraction, percentToFraction).call(this, percent)));
    }
    /**
   * @returns A new {@link BN} with the provided decimals.
   */ toDecimals(decimals) {
        if (decimals === _class_private_field_get(this, _cfg).decimals) return this;
        return decimals > _class_private_field_get(this, _cfg).decimals ? this.toGreaterDecimals(decimals) : this.toLessDecimals(decimals);
    }
    /**
   * @returns A new {@link BN} with the provided decimals, less than current one,
   * otherwise throws {@link RuntimeError}.
   */ toLessDecimals(decimals) {
        (0, _assertions.assertDecimals)(_class_private_field_get(this, _cfg).decimals, decimals, _enums.BN_ASSERT_DECIMALS_OP.LESS);
        return _class_private_method_get(this, _toDecimals, toDecimals).call(this, decimals);
    }
    /**
   * @returns A new {@link BN} with the provided decimals, greater than current one,
   * otherwise throws {@link RuntimeError}.
   */ toGreaterDecimals(decimals) {
        (0, _assertions.assertDecimals)(_class_private_field_get(this, _cfg).decimals, decimals, _enums.BN_ASSERT_DECIMALS_OP.GREATER);
        return _class_private_method_get(this, _toDecimals, toDecimals).call(this, decimals);
    }
    /**
   * @returns A string representing the value of `this` fixed-point notation and
   * formatted according to the properties of the {@link BN.config.format} and
   * `format` (if exist) objects.
   */ format(format = {}) {
        return (0, _format.format)(this.toString(), _object_spread({}, BN.config.format, format));
    }
    /**
   * @returns A new {@link BN} whose value is the value of `this` rounded to
   * decimals using {@link BN_ROUNDING} rounding mode.
   */ round(decimals, rounding) {
        return BN.fromBigInt((0, _round.round)(this, decimals, rounding !== null && rounding !== void 0 ? rounding : BN.config.rounding), _object_spread_props(_object_spread({}, _class_private_field_get(this, _cfg)), {
            decimals
        }));
    }
    /**
   * @returns A human-readable float string.
   */ toString() {
        let val = this.value;
        const decimals = _class_private_field_get(this, _cfg).decimals;
        const negative = this.isNegative ? '-' : '';
        const isLessOne = val.length < decimals;
        if (this.isNegative) val = val.slice(1);
        if (isLessOne) val = val.padStart(decimals, '0');
        const pointIdx = val.length - decimals;
        val = val.slice(0, pointIdx) + '.' + val.slice(pointIdx);
        if (val.startsWith('.')) val = '0' + val;
        return negative + val;
    }
    /**
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description}
   */ toJSON() {
        return this.value;
    }
    /**
   *
   * @param value - Always BigInt * ten power of {@link BN.precision}
   * @param config - The config of the value.
   * @protected
   * @returns A new {@link BN} instance.
   */ constructor(value, config){
        _class_private_field_init(this, _one, {
            get: get_one,
            set: void 0
        });
        _class_private_field_init(this, _hundred, {
            get: get_hundred,
            set: void 0
        });
        _class_private_method_init(this, _toDecimals);
        _class_private_method_init(this, _percentToFraction);
        /**
   * Raw value multiplied by ten power of {@link BN.precision}.
   */ _class_private_field_init(this, _raw, {
            writable: true,
            value: void 0
        });
        /**
   * {@link BN} instance config.
   */ _class_private_field_init(this, _cfg, {
            writable: true,
            value: void 0
        });
        /**
   * Ten power of {@link BN.precision}.
   */ _class_private_field_init(this, _tens, {
            writable: true,
            value: (0, _decimals.getTens)(BN.precision)
        });
        _class_private_field_set(this, _raw, value);
        _class_private_field_set(this, _cfg, config);
    }
} /*#__PURE__*/  /*#__PURE__*/  /*#__PURE__*/  /*#__PURE__*/  /*#__PURE__*/  /*#__PURE__*/  /*#__PURE__*/ ;
function get_one() {
    return BN.fromRaw(1, _class_private_field_get(this, _cfg));
}
function get_hundred() {
    return BN.fromRaw(100, _class_private_field_get(this, _cfg));
}
function toDecimals(decimals) {
    return new BN(_class_private_field_get(this, _raw), _object_spread_props(_object_spread({}, _class_private_field_get(this, _cfg)), {
        decimals
    }));
}
function percentToFraction(percent) {
    return BN.fromRaw(percent, _class_private_field_get(this, _cfg)).div(_class_private_field_get(this, _hundred));
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ibi9ibi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUZBVUxUX0JOX1BSRUNJU0lPTiB9IGZyb20gJ0AvY29uc3QnXG5pbXBvcnQgeyBCTl9BU1NFUlRfREVDSU1BTFNfT1AsIEJOX1JPVU5ESU5HLCBERUNJTUFMUyB9IGZyb20gJ0AvZW51bXMnXG5pbXBvcnQgeyBhc3NlcnQsIGlzSGV4LCBpc0ludGVnZXJTdHJpbmcgfSBmcm9tICdAL2hlbHBlcnMnXG5pbXBvcnQgdHlwZSB7XG4gIEJuQ29uZmlnLFxuICBCbkNvbmZpZ0xpa2UsXG4gIEJuRm9ybWF0Q29uZmlnLFxuICBCbkdsb2JhbENvbmZpZyxcbiAgQm5MaWtlLFxufSBmcm9tICdAL3R5cGVzJ1xuXG5pbXBvcnQgeyBhc3NlcnREZWNpbWFscywgYXNzZXJ0RGVjaW1hbHNJbnRlZ2VyIH0gZnJvbSAnLi9hc3NlcnRpb25zJ1xuaW1wb3J0IHsgZ2V0VGVucywgdG9EZWNpbWFscyB9IGZyb20gJy4vZGVjaW1hbHMnXG5pbXBvcnQgeyBmb3JtYXQgYXMgX2Zvcm1hdCB9IGZyb20gJy4vZm9ybWF0J1xuaW1wb3J0IHsgcGFyc2VDb25maWcsIHBhcnNlTnVtYmVyU3RyaW5nIH0gZnJvbSAnLi9wYXJzZXJzJ1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tICcuL3JvdW5kJ1xuXG5sZXQgZ2xvYmFsQ29uZmlnOiBCbkdsb2JhbENvbmZpZyA9IHtcbiAgcHJlY2lzaW9uOiBERUZBVUxUX0JOX1BSRUNJU0lPTixcbiAgcm91bmRpbmc6IEJOX1JPVU5ESU5HLkRFRkFVTFQsXG4gIGRlY2ltYWxzOiBERUNJTUFMUy5XRUksXG4gIGZvcm1hdDoge1xuICAgIHByZWZpeDogJycsXG4gICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxuICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXG4gICAgZ3JvdXBTaXplOiAzLFxuICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICcgJyxcbiAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcbiAgICBzdWZmaXg6ICcnLFxuICB9LFxufVxuXG5leHBvcnQgY2xhc3MgQk4ge1xuICAvKipcbiAgICogU29saWRpdHkgbWF4aW11bSB1aW50MjU2IHZhbHVlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXQgTUFYX1VJTlQyNTYoKSB7XG4gICAgcmV0dXJuIEJOLmZyb21CaWdJbnQoMm4gKiogMjU2biAtIDFuLCAxKVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXQgV0VJX0RFQ0lNQUxTKCkge1xuICAgIHJldHVybiBERUNJTUFMUy5XRUlcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IFJPVU5ESU5HKCkge1xuICAgIHJldHVybiBCTl9ST1VORElOR1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBCTn0gY2xhc3MgZ2xvYmFsIGNvbmZpZy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IGNvbmZpZygpOiBCbkdsb2JhbENvbmZpZyB7XG4gICAgcmV0dXJuIGdsb2JhbENvbmZpZ1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBCTn0gY2xhc3MgZ2xvYmFsIHByZWNpc2lvbi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IHByZWNpc2lvbigpOiBudW1iZXIge1xuICAgIHJldHVybiBnbG9iYWxDb25maWcucHJlY2lzaW9uXG4gIH1cblxuICAvKipcbiAgICogUmF3IHZhbHVlIG11bHRpcGxpZWQgYnkgdGVuIHBvd2VyIG9mIHtAbGluayBCTi5wcmVjaXNpb259LlxuICAgKi9cbiAgcmVhZG9ubHkgI3JhdzogYmlnaW50XG5cbiAgLyoqXG4gICAqIHtAbGluayBCTn0gaW5zdGFuY2UgY29uZmlnLlxuICAgKi9cbiAgcmVhZG9ubHkgI2NmZzogQm5Db25maWdcblxuICAvKipcbiAgICogVGVuIHBvd2VyIG9mIHtAbGluayBCTi5wcmVjaXNpb259LlxuICAgKi9cbiAgcmVhZG9ubHkgI3RlbnM6IGJpZ2ludCA9IGdldFRlbnMoQk4ucHJlY2lzaW9uKVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgLSBBbHdheXMgQmlnSW50ICogdGVuIHBvd2VyIG9mIHtAbGluayBCTi5wcmVjaXNpb259XG4gICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlnIG9mIHRoZSB2YWx1ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IGluc3RhbmNlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHZhbHVlOiBiaWdpbnQsIGNvbmZpZzogQm5Db25maWcpIHtcbiAgICB0aGlzLiNyYXcgPSB2YWx1ZVxuICAgIHRoaXMuI2NmZyA9IGNvbmZpZ1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgbmV3IHtAbGluayBCbkdsb2JhbENvbmZpZ30gY29uZmlnIHRvIHRoZSB7QGxpbmsgQk59LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzZXRDb25maWcoY29uZmlnOiBQYXJ0aWFsPEJuR2xvYmFsQ29uZmlnPik6IHZvaWQge1xuICAgIGdsb2JhbENvbmZpZyA9IHsgLi4uZ2xvYmFsQ29uZmlnLCAuLi5jb25maWcgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiBgYXJnYCBpcyB7QGxpbmsgQk59IGluc3RhbmNlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBpc0JuKGFyZzogdW5rbm93bik6IGFyZyBpcyBCTiB7XG4gICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIEJOXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEJOfSBpZiBgdmFsdWVgIGFyZ3VtZW50IGlzIHZhbGlkIGJpZyBpbnQgbGlrZSB2YWx1ZSxcbiAgICogb3RoZXJ3aXNlIHRocm93cyB7QGxpbmsgUnVudGltZUVycm9yfS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3Qgb25lRXRoID0gQk4uZnJvbUJpZ0ludCgnMTAwMDAwMDAwMDAwMDAwMDAwMCcsIDE4KVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUJpZ0ludCh2YWx1ZTogQm5MaWtlLCBkZWNpbWFsc09yQ29uZmlnPzogQm5Db25maWdMaWtlKTogQk4ge1xuICAgIGxldCB2YWwgPSB2YWx1ZVxuXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWwgPSBpc0hleCh2YWwpID8gQmlnSW50KHZhbCkudG9TdHJpbmcoKSA6IHZhbFxuICAgICAgYXNzZXJ0KGlzSW50ZWdlclN0cmluZyh2YWwpLCAnSW52YWxpZCBiaWcgaW50IHN0cmluZycpXG4gICAgfVxuICAgIGNvbnN0IGNmZyA9IHBhcnNlQ29uZmlnKGRlY2ltYWxzT3JDb25maWcgPz8gQk4uY29uZmlnLmRlY2ltYWxzKVxuICAgIGNvbnN0IHBhcnNlZCA9IEJpZ0ludChCTi5pc0JuKHZhbCkgPyB2YWwudmFsdWUgOiB2YWwpXG4gICAgY29uc3Qgd2l0aFByZWNpc2lvbiA9IHBhcnNlZCAqIGdldFRlbnMoQk4ucHJlY2lzaW9uIC0gY2ZnLmRlY2ltYWxzKVxuICAgIHJldHVybiBuZXcgQk4od2l0aFByZWNpc2lvbiwgY2ZnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBCTn0gaWYgYHZhbHVlYCBhcmd1bWVudCBpcyB2YWxpZCBpbnRlZ2VyIG9yIGZsb2F0IHZhbHVlLFxuICAgKiBvdGhlcndpc2UgdGhyb3dzIHtAbGluayBSdW50aW1lRXJyb3J9LlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBvbmVFdGggPSBCTi5mcm9tUmF3KDEsIDE4KVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVJhdyhcbiAgICB2YWx1ZTogRXhjbHVkZTxCbkxpa2UsIEJOPixcbiAgICBkZWNpbWFsc09yQ29uZmlnPzogQm5Db25maWdMaWtlLFxuICApOiBCTiB7XG4gICAgY29uc3QgdmFsID0gU3RyaW5nKHZhbHVlKVxuICAgIGNvbnN0IGNmZyA9IHBhcnNlQ29uZmlnKGRlY2ltYWxzT3JDb25maWcgPz8gQk4uY29uZmlnLmRlY2ltYWxzKVxuICAgIHJldHVybiBuZXcgQk4oQmlnSW50KHBhcnNlTnVtYmVyU3RyaW5nKHZhbCkpLCBjZmcpXG4gIH1cblxuICAvKipcbiAgICogIEByZXR1cm5zIEEgbWluaW11bSB7QGxpbmsgQk59IHZhbHVlIGZyb20gdGhlIGBhcmdzYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWluKC4uLmFyZ3M6IEJOW10pOiBCTiB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKChtaW4sIGVsKSA9PiAoZWwucmF3IDwgbWluLnJhdyA/IGVsIDogbWluKSlcbiAgfVxuXG4gIC8qKlxuICAgKiAgQHJldHVybnMgQSBtYXhpbXVtIHtAbGluayBCTn0gdmFsdWUgZnJvbSB0aGUgYGFyZ3NgLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYXgoLi4uYXJnczogQk5bXSk6IEJOIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2UoKG1pbiwgZWwpID0+IChlbC5yYXcgPiBtaW4ucmF3ID8gZWwgOiBtaW4pKVxuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBBIGB0aGlzYCBjb25maWcuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNvbmZpZygpOiBCbkNvbmZpZyB7XG4gICAgcmV0dXJuIHRoaXMuI2NmZ1xuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gICAqL1xuICBwdWJsaWMgZ2V0IGRlY2ltYWxzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuI2NmZy5kZWNpbWFsc1xuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB0aGlzYCB2YWx1ZSBpcyB6ZXJvLlxuICAgKi9cbiAgcHVibGljIGdldCBpc1plcm8oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuI3JhdyA9PT0gMG5cbiAgfVxuXG4gIC8qKlxuICAgKiAgQHJldHVybnMgYHRydWVgIGlmIHRoZSBgdGhpc2AgdmFsdWUgaXMgcG9zaXRpdmUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzUG9zaXRpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuI3JhdyA+IDBuXG4gIH1cblxuICAvKipcbiAgICogIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHRoaXNgIHZhbHVlIGlzIG5lZ2F0aXZlLlxuICAgKi9cbiAgcHVibGljIGdldCBpc05lZ2F0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLiNyYXcgPCAwblxuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBBIHJhdyB7QGxpbmsgQmlnSW50fSB2YWx1ZSB3aXRoIHRoZSB7QGxpbmsgQk4ucHJlY2lzaW9ufSBhcHBsaWVkLlxuICAgKi9cbiAgcHVibGljIGdldCByYXcoKTogYmlnaW50IHtcbiAgICByZXR1cm4gdGhpcy4jcmF3XG4gIH1cblxuICAvKipcbiAgICogIEByZXR1cm5zIEEgYmlnIGludCBzdHJpbmcgdmFsdWUgd2l0aCB0aGUgYHRoaXMuZGVjaW1hbHNgIGFwcGxpZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHZhbHVlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRvRGVjaW1hbHModGhpcy4jcmF3LCBCTi5wcmVjaXNpb24sIHRoaXMuI2NmZy5kZWNpbWFscykudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdpdGggdGhlIHJlc3VsdCBvZiB0aGlzIGFkZGVkIHRvIGBvdGhlcmAuXG4gICAqL1xuICBwdWJsaWMgYWRkKG90aGVyOiBCTik6IEJOIHtcbiAgICByZXR1cm4gbmV3IEJOKHRoaXMuI3JhdyArIG90aGVyLnJhdywgdGhpcy4jY2ZnKVxuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdpdGggdGhlIHJlc3VsdCBvZiBvdGhlciBzdWJ0cmFjdGVkIGZyb20gdGhpcy5cbiAgICovXG4gIHB1YmxpYyBzdWIob3RoZXI6IEJOKTogQk4ge1xuICAgIHJldHVybiBuZXcgQk4odGhpcy4jcmF3IC0gb3RoZXIucmF3LCB0aGlzLiNjZmcpXG4gIH1cblxuICAvKipcbiAgICogIEByZXR1cm5zIEEgbmV3IHtAbGluayBCTn0gd2l0aCB0aGUgcmVzdWx0IG9mIHRoaXMgZGl2aWRlZCBieSBgb3RoZXJgLlxuICAgKi9cbiAgcHVibGljIGRpdihvdGhlcjogQk4pOiBCTiB7XG4gICAgYXNzZXJ0KG90aGVyLnJhdyAhPT0gMG4sICdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKVxuICAgIHJldHVybiBuZXcgQk4oKHRoaXMuI3JhdyAqIHRoaXMuI3RlbnMpIC8gb3RoZXIucmF3LCB0aGlzLiNjZmcpXG4gIH1cblxuICAvKipcbiAgICogIEByZXR1cm5zIEEgbmV3IHtAbGluayBCTn0gd2l0aCB0aGUgcmVzdWx0IG9mIHRoaXMgbXVsdGlwbGllZCBieSBgb3RoZXJgLlxuICAgKi9cbiAgcHVibGljIG11bChvdGhlcjogQk4pOiBCTiB7XG4gICAgcmV0dXJuIG5ldyBCTigodGhpcy4jcmF3ICogb3RoZXIucmF3KSAvIHRoaXMuI3RlbnMsIHRoaXMuI2NmZylcbiAgfVxuXG4gIC8qKlxuICAgKiAgQHJldHVybnMgQSBjb21wYXJpc29uIHJlc3VsdCBiZXR3ZWVuIHRoaXMgYW5kIG90aGVyLlxuICAgKi9cbiAgcHVibGljIGNtcChvdGhlcjogQk4pOiBudW1iZXIge1xuICAgIGNvbnN0IGEgPSB0aGlzLiNyYXdcbiAgICBjb25zdCBiID0gb3RoZXIucmF3XG4gICAgaWYgKGEgPCBiKSByZXR1cm4gLTFcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8qKlxuICAgKiAgQHJldHVybnMgYHRydWVgIGlmIGBvdGhlcmAgaXMgZXF1YWwgdG8gYHRoaXNgLlxuICAgKi9cbiAgcHVibGljIGVxKG90aGVyOiBCTik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNtcChvdGhlcikgPT09IDBcbiAgfVxuXG4gIC8qKlxuICAgKiAgQHJldHVybnMgYHRydWVgIGlmIGBvdGhlcmAgaXMgbGVzcyB0aGFuIHRvIGB0aGlzYC5cbiAgICovXG4gIHB1YmxpYyBsdChvdGhlcjogQk4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jbXAob3RoZXIpIDwgMFxuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBgdHJ1ZWAgaWYgYG90aGVyYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHRoaXNgLlxuICAgKi9cbiAgcHVibGljIGx0ZShvdGhlcjogQk4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jbXAob3RoZXIpIDw9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiAgQHJldHVybnMgYHRydWVgIGlmIGBvdGhlcmAgaXMgZ3JlYXRlciB0aGFuIHRvIGB0aGlzYC5cbiAgICovXG4gIHB1YmxpYyBndChvdGhlcjogQk4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jbXAob3RoZXIpID4gMFxuICB9XG5cbiAgLyoqXG4gICAqICBAcmV0dXJucyBgdHJ1ZWAgaWYgYG90aGVyYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHRoaXNgLlxuICAgKi9cbiAgcHVibGljIGd0ZShvdGhlcjogQk4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jbXAob3RoZXIpID49IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiBgdGhpc2AuXG4gICAqIEB0aHJvd3Mge0BsaW5rIFJ1bnRpbWVFcnJvcn0gaWYgYEJOLnByZWNpc2lvbmAgaXMgbm90IGV2ZW4gbnVtYmVyLlxuICAgKi9cbiAgcHVibGljIHNxcnQoKTogQk4ge1xuICAgIGFzc2VydCghdGhpcy5pc05lZ2F0aXZlLCAnc3FydCBvZiBuZWdhdGl2ZSBudW1iZXJzIGlzIG5vdCBzdXBwb3J0ZWQnKVxuXG4gICAgaWYgKHRoaXMuaXNaZXJvKSByZXR1cm4gdGhpc1xuXG4gICAgY29uc3QgYmFzZSA9IHRoaXMucmF3ICogdGhpcy4jdGVuc1xuICAgIGxldCB4MCA9IGJhc2UgLyAyblxuICAgIGxldCB4MSA9ICh4MCArIGJhc2UgLyB4MCkgLyAyblxuXG4gICAgd2hpbGUgKHgwIC0geDEgPiAxbikge1xuICAgICAgeDAgPSB4MVxuICAgICAgeDEgPSAoeDAgKyBiYXNlIC8geDApIC8gMm5cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJOKHgxLCB0aGlzLiNjZmcpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEJOfSB3aG9zZSB2YWx1ZSBpcyBuZWdhdGVkIGB0aGlzYCAobXVsdGlwbGllZCBieSAtMSkuXG4gICAqL1xuICBwdWJsaWMgbmVnYXRlZCgpOiBCTiB7XG4gICAgcmV0dXJuIG5ldyBCTih0aGlzLiNyYXcgKiAtMW4sIHRoaXMuI2NmZylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdob3NlIHZhbHVlIGlzIGFic29sdXRlIGB0aGlzYC5cbiAgICovXG4gIHB1YmxpYyBhYnMoKTogQk4ge1xuICAgIHJldHVybiB0aGlzLmlzUG9zaXRpdmUgPyB0aGlzIDogdGhpcy5uZWdhdGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdob3NlIHZhbHVlIGlzIGB0aGlzYCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mIGBleHBvbmVudGAuXG4gICAqL1xuICBwdWJsaWMgcG93KGV4cG9uZW50OiBudW1iZXIpOiBCTiB7XG4gICAgYXNzZXJ0RGVjaW1hbHNJbnRlZ2VyKGV4cG9uZW50KVxuICAgIGNvbnN0IGV4cCA9IEJpZ0ludChleHBvbmVudClcbiAgICBjb25zdCBmciA9IGdldFRlbnMoTnVtYmVyKEJpZ0ludChCTi5wcmVjaXNpb24pICogKGV4cCAtIDFuKSkpXG4gICAgcmV0dXJuIG5ldyBCTih0aGlzLiNyYXcgKiogZXhwIC8gZnIsIHRoaXMuI2NmZylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdob3NlIHZhbHVlIGlzIHBlcmNlbnRhZ2Ugb2YgYHRoaXNgIHZhbHVlLlxuICAgKi9cbiAgcHVibGljIHBlcmNlbnQocGVyY2VudDogbnVtYmVyKTogQk4ge1xuICAgIHJldHVybiB0aGlzLm11bCh0aGlzLiNwZXJjZW50VG9GcmFjdGlvbihwZXJjZW50KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdob3NlIHZhbHVlIGlzIGB0aGlzYCB3aXRoIGFkZGVkIHBlcmNlbnRhZ2UuXG4gICAqL1xuICBwdWJsaWMgYWRkUGVyY2VudChwZXJjZW50OiBudW1iZXIpOiBCTiB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMuI29uZS5hZGQodGhpcy4jcGVyY2VudFRvRnJhY3Rpb24ocGVyY2VudCkpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBCTn0gd2hvc2UgdmFsdWUgaXMgYHRoaXNgIHdpdGggc3VidHJhY3RlZCBwZXJjZW50YWdlLlxuICAgKi9cbiAgcHVibGljIHN1YlBlcmNlbnQocGVyY2VudDogbnVtYmVyKTogQk4ge1xuICAgIHJldHVybiB0aGlzLmRpdih0aGlzLiNvbmUuYWRkKHRoaXMuI3BlcmNlbnRUb0ZyYWN0aW9uKHBlcmNlbnQpKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgQk59IHdpdGggdGhlIHByb3ZpZGVkIGRlY2ltYWxzLlxuICAgKi9cbiAgcHVibGljIHRvRGVjaW1hbHMoZGVjaW1hbHM6IG51bWJlcik6IEJOIHtcbiAgICBpZiAoZGVjaW1hbHMgPT09IHRoaXMuI2NmZy5kZWNpbWFscykgcmV0dXJuIHRoaXNcblxuICAgIHJldHVybiBkZWNpbWFscyA+IHRoaXMuI2NmZy5kZWNpbWFsc1xuICAgICAgPyB0aGlzLnRvR3JlYXRlckRlY2ltYWxzKGRlY2ltYWxzKVxuICAgICAgOiB0aGlzLnRvTGVzc0RlY2ltYWxzKGRlY2ltYWxzKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBCTn0gd2l0aCB0aGUgcHJvdmlkZWQgZGVjaW1hbHMsIGxlc3MgdGhhbiBjdXJyZW50IG9uZSxcbiAgICogb3RoZXJ3aXNlIHRocm93cyB7QGxpbmsgUnVudGltZUVycm9yfS5cbiAgICovXG4gIHB1YmxpYyB0b0xlc3NEZWNpbWFscyhkZWNpbWFsczogbnVtYmVyKTogQk4ge1xuICAgIGFzc2VydERlY2ltYWxzKHRoaXMuI2NmZy5kZWNpbWFscywgZGVjaW1hbHMsIEJOX0FTU0VSVF9ERUNJTUFMU19PUC5MRVNTKVxuICAgIHJldHVybiB0aGlzLiN0b0RlY2ltYWxzKGRlY2ltYWxzKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIEEgbmV3IHtAbGluayBCTn0gd2l0aCB0aGUgcHJvdmlkZWQgZGVjaW1hbHMsIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9uZSxcbiAgICogb3RoZXJ3aXNlIHRocm93cyB7QGxpbmsgUnVudGltZUVycm9yfS5cbiAgICovXG4gIHB1YmxpYyB0b0dyZWF0ZXJEZWNpbWFscyhkZWNpbWFsczogbnVtYmVyKTogQk4ge1xuICAgIGFzc2VydERlY2ltYWxzKHRoaXMuI2NmZy5kZWNpbWFscywgZGVjaW1hbHMsIEJOX0FTU0VSVF9ERUNJTUFMU19PUC5HUkVBVEVSKVxuICAgIHJldHVybiB0aGlzLiN0b0RlY2ltYWxzKGRlY2ltYWxzKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgYHRoaXNgIGZpeGVkLXBvaW50IG5vdGF0aW9uIGFuZFxuICAgKiBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB7QGxpbmsgQk4uY29uZmlnLmZvcm1hdH0gYW5kXG4gICAqIGBmb3JtYXRgIChpZiBleGlzdCkgb2JqZWN0cy5cbiAgICovXG4gIHB1YmxpYyBmb3JtYXQoZm9ybWF0OiBCbkZvcm1hdENvbmZpZyA9IHt9KTogc3RyaW5nIHtcbiAgICByZXR1cm4gX2Zvcm1hdCh0aGlzLnRvU3RyaW5nKCksIHsgLi4uQk4uY29uZmlnLmZvcm1hdCwgLi4uZm9ybWF0IH0pXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgQSBuZXcge0BsaW5rIEJOfSB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgYHRoaXNgIHJvdW5kZWQgdG9cbiAgICogZGVjaW1hbHMgdXNpbmcge0BsaW5rIEJOX1JPVU5ESU5HfSByb3VuZGluZyBtb2RlLlxuICAgKi9cbiAgcHVibGljIHJvdW5kKGRlY2ltYWxzOiBudW1iZXIsIHJvdW5kaW5nPzogQk5fUk9VTkRJTkcpOiBCTiB7XG4gICAgcmV0dXJuIEJOLmZyb21CaWdJbnQoXG4gICAgICByb3VuZCh0aGlzLCBkZWNpbWFscywgcm91bmRpbmcgPz8gQk4uY29uZmlnLnJvdW5kaW5nKSxcbiAgICAgIHsgLi4udGhpcy4jY2ZnLCBkZWNpbWFscyB9LFxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBBIGh1bWFuLXJlYWRhYmxlIGZsb2F0IHN0cmluZy5cbiAgICovXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIGxldCB2YWwgPSB0aGlzLnZhbHVlXG5cbiAgICBjb25zdCBkZWNpbWFscyA9IHRoaXMuI2NmZy5kZWNpbWFsc1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gdGhpcy5pc05lZ2F0aXZlID8gJy0nIDogJydcbiAgICBjb25zdCBpc0xlc3NPbmUgPSB2YWwubGVuZ3RoIDwgZGVjaW1hbHNcblxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUpIHZhbCA9IHZhbC5zbGljZSgxKVxuXG4gICAgaWYgKGlzTGVzc09uZSkgdmFsID0gdmFsLnBhZFN0YXJ0KGRlY2ltYWxzLCAnMCcpXG5cbiAgICBjb25zdCBwb2ludElkeCA9IHZhbC5sZW5ndGggLSBkZWNpbWFsc1xuXG4gICAgdmFsID0gdmFsLnNsaWNlKDAsIHBvaW50SWR4KSArICcuJyArIHZhbC5zbGljZShwb2ludElkeClcblxuICAgIGlmICh2YWwuc3RhcnRzV2l0aCgnLicpKSB2YWwgPSAnMCcgKyB2YWxcblxuICAgIHJldHVybiBuZWdhdGl2ZSArIHZhbFxuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9KU09OL3N0cmluZ2lmeSNkZXNjcmlwdGlvbn1cbiAgICovXG4gIHB1YmxpYyB0b0pTT04oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgZ2V0ICNvbmUoKTogQk4ge1xuICAgIHJldHVybiBCTi5mcm9tUmF3KDEsIHRoaXMuI2NmZylcbiAgfVxuXG4gIGdldCAjaHVuZHJlZCgpOiBCTiB7XG4gICAgcmV0dXJuIEJOLmZyb21SYXcoMTAwLCB0aGlzLiNjZmcpXG4gIH1cblxuICAjdG9EZWNpbWFscyhkZWNpbWFsczogbnVtYmVyKTogQk4ge1xuICAgIHJldHVybiBuZXcgQk4odGhpcy4jcmF3LCB7IC4uLnRoaXMuI2NmZywgZGVjaW1hbHMgfSlcbiAgfVxuXG4gICNwZXJjZW50VG9GcmFjdGlvbihwZXJjZW50OiBudW1iZXIpOiBCTiB7XG4gICAgcmV0dXJuIEJOLmZyb21SYXcocGVyY2VudCwgdGhpcy4jY2ZnKS5kaXYodGhpcy4jaHVuZHJlZClcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkJOIiwiZ2xvYmFsQ29uZmlnIiwicHJlY2lzaW9uIiwiREVGQVVMVF9CTl9QUkVDSVNJT04iLCJyb3VuZGluZyIsIkJOX1JPVU5ESU5HIiwiREVGQVVMVCIsImRlY2ltYWxzIiwiREVDSU1BTFMiLCJXRUkiLCJmb3JtYXQiLCJwcmVmaXgiLCJkZWNpbWFsU2VwYXJhdG9yIiwiZ3JvdXBTZXBhcmF0b3IiLCJncm91cFNpemUiLCJmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIiwiZnJhY3Rpb25Hcm91cFNpemUiLCJzdWZmaXgiLCJNQVhfVUlOVDI1NiIsImZyb21CaWdJbnQiLCJXRUlfREVDSU1BTFMiLCJST1VORElORyIsImNvbmZpZyIsInNldENvbmZpZyIsImlzQm4iLCJhcmciLCJ2YWx1ZSIsImRlY2ltYWxzT3JDb25maWciLCJ2YWwiLCJpc0hleCIsIkJpZ0ludCIsInRvU3RyaW5nIiwiYXNzZXJ0IiwiaXNJbnRlZ2VyU3RyaW5nIiwiY2ZnIiwicGFyc2VDb25maWciLCJwYXJzZWQiLCJ3aXRoUHJlY2lzaW9uIiwiZ2V0VGVucyIsImZyb21SYXciLCJTdHJpbmciLCJwYXJzZU51bWJlclN0cmluZyIsIm1pbiIsImFyZ3MiLCJyZWR1Y2UiLCJlbCIsInJhdyIsIm1heCIsImlzWmVybyIsImlzUG9zaXRpdmUiLCJpc05lZ2F0aXZlIiwidG9EZWNpbWFscyIsImFkZCIsIm90aGVyIiwic3ViIiwiZGl2IiwidGVucyIsIm11bCIsImNtcCIsImEiLCJiIiwiZXEiLCJsdCIsImx0ZSIsImd0IiwiZ3RlIiwic3FydCIsImJhc2UiLCJ4MCIsIngxIiwibmVnYXRlZCIsImFicyIsInBvdyIsImV4cG9uZW50IiwiYXNzZXJ0RGVjaW1hbHNJbnRlZ2VyIiwiZXhwIiwiZnIiLCJOdW1iZXIiLCJwZXJjZW50IiwicGVyY2VudFRvRnJhY3Rpb24iLCJhZGRQZXJjZW50Iiwib25lIiwic3ViUGVyY2VudCIsInRvR3JlYXRlckRlY2ltYWxzIiwidG9MZXNzRGVjaW1hbHMiLCJhc3NlcnREZWNpbWFscyIsIkJOX0FTU0VSVF9ERUNJTUFMU19PUCIsIkxFU1MiLCJHUkVBVEVSIiwiX2Zvcm1hdCIsInJvdW5kIiwibmVnYXRpdmUiLCJpc0xlc3NPbmUiLCJsZW5ndGgiLCJzbGljZSIsInBhZFN0YXJ0IiwicG9pbnRJZHgiLCJzdGFydHNXaXRoIiwidG9KU09OIiwiaHVuZHJlZCJdLCJyYW5nZU1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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