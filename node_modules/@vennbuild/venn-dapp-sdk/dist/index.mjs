var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/errors/api.errors.ts
var api_errors_exports = {};
__export(api_errors_exports, {
  AbortedError: () => AbortedError,
  BadRequestError: () => BadRequestError,
  CanceledError: () => CanceledError,
  ConnectionRefusedError: () => ConnectionRefusedError,
  NetworkError: () => NetworkError,
  TimeoutError: () => TimeoutError
});
import { CanceledError } from "axios";
var ConnectionRefusedError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var NetworkError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var TimeoutError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var AbortedError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var BadRequestError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// src/errors/server.errors.ts
var server_errors_exports = {};
__export(server_errors_exports, {
  InternalError: () => InternalError,
  NoMonitoredAssetsError: () => NoMonitoredAssetsError,
  NoPolicyCallInTraceError: () => NoPolicyCallInTraceError,
  TxRejectedError: () => TxRejectedError
});
var TxRejectedError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var NoPolicyCallInTraceError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var NoMonitoredAssetsError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var InternalError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// src/errors/venn-client.errors.ts
var venn_client_errors_exports = {};
__export(venn_client_errors_exports, {
  InvalidInitParamsError: () => InvalidInitParamsError,
  MissingChainIdError: () => MissingChainIdError
});
var InvalidInitParamsError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var MissingChainIdError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// src/errors/index.ts
var errors = __spreadValues(__spreadValues(__spreadValues({}, server_errors_exports), api_errors_exports), venn_client_errors_exports);

// src/venn-client/index.ts
import {
  CoinbaseProvider,
  createProvider,
  errors as web3Errors,
  MetamaskProvider,
  ProviderDetector,
  PROVIDERS
} from "@distributedlab/w3p";
import axios from "axios";

// src/helpers/error.helpers.ts
import { isAxiosError } from "axios";
var isLegacyServerLikeError = (error) => {
  var _a, _b;
  return typeof error === "object" && error !== null && typeof ((_a = error.response) == null ? void 0 : _a.data) === "object" && ((_b = error.response) == null ? void 0 : _b.data) !== null && ["message", "status"].every((prop) => {
    var _a2;
    return Reflect.has((_a2 = error.response) == null ? void 0 : _a2.data, prop);
  });
};
var parseServerError = (error) => {
  var _a;
  if (!isAxiosError(error)) return error;
  if (!isLegacyServerLikeError(error)) return error;
  const responseData = (_a = error.response) == null ? void 0 : _a.data;
  const message = responseData.message;
  const status = responseData.status;
  const _parseServerError = (message2) => {
    const _message = message2.toLowerCase();
    switch (true) {
      case _message.includes("policy"):
        return new errors.NoPolicyCallInTraceError(message2);
      case _message.includes("invalid request"):
        return new errors.BadRequestError(message2);
      case _message.includes("monitored assets"):
        return new errors.NoMonitoredAssetsError(message2);
      default:
        return new errors.InternalError(message2);
    }
  };
  switch (status) {
    case "Rejected":
      return new errors.TxRejectedError(message);
    case "Error":
      return _parseServerError(message);
    default:
      return new errors.InternalError(message);
  }
};
var parseApiError = (error) => {
  if (!isAxiosError(error)) return null;
  switch (error.code) {
    case "ECONNREFUSED" /* connectionRefused */:
      return new errors.ConnectionRefusedError(error.message);
    case "ERR_NETWORK" /* network */:
      return new errors.NetworkError(error.message);
    case "ETIMEDOUT" /* timeout */:
      return new errors.TimeoutError(error.message);
    case "ECONNABORTED" /* aborted */:
      return new errors.AbortedError(error.message);
    case "ERR_BAD_REQUEST" /* badRequest */:
      return new errors.BadRequestError(error.message);
    default:
      return null;
  }
};

// src/helpers/validation.helpers.ts
import { isAddress } from "ethers";
var isValidUrl = (url) => {
  try {
    new URL(url);
    return true;
  } catch (e) {
    return false;
  }
};
var isValidEthereumAddress = (address) => isAddress(address);

// src/venn-client/index.ts
var supportedProviders = {
  [PROVIDERS.Metamask]: MetamaskProvider,
  [PROVIDERS.Coinbase]: CoinbaseProvider
};
var VennClient = class {
  /**
   * Creates a new VennClient instance.
   * @param {string} opts.url - The URL of the Venn Node.
   * @param {string} opts.vennPolicyAddress - The address of the policy.
   * @param {boolean} [opts.strict=true] - Optional. Whether to throw an error if the response Venn Network is not 'Approved' or if an error occurs. If set to false, will return the request data on failure. Defaults to true.
   * @throws {Error} If any required property is missing.
   */
  constructor(opts) {
    var _a;
    this.validateRequiredProperties(opts);
    this.initProvider();
    this.url = opts.vennURL;
    this.vennPolicyAddress = opts.vennPolicyAddress;
    this.strict = (_a = opts.strict) != null ? _a : true;
    this.apiInstance = axios.create({ baseURL: this.url });
  }
  initProvider() {
    return __async(this, null, function* () {
      if (typeof window === "undefined") return;
      try {
        const providerDetector = new ProviderDetector();
        yield providerDetector.init();
        const availableProviders = Object.keys(providerDetector.providers);
        if (!availableProviders.length) throw new web3Errors.ProviderInjectedInstanceNotFoundError();
        const providerProxyConstructor = supportedProviders[availableProviders[0]];
        this.web3Provider = yield createProvider(providerProxyConstructor, { providerDetector });
      } catch (error) {
        console.warn(
          `Web3Provider in VennClient was not initialized: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }
  getSignature(txData) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      try {
        const requestData = __spreadProps(__spreadValues({}, txData), {
          approvingPolicyAddress: this.vennPolicyAddress,
          chainId: (_b = txData == null ? void 0 : txData.chainId) != null ? _b : (_a = this.web3Provider) == null ? void 0 : _a.chainId
        });
        if (!requestData.chainId)
          throw new errors.MissingChainIdError(
            "Chain id was not provided in request and was not available via injected provider"
          );
        const { data: signedData } = yield this.apiInstance.post("", requestData);
        if (signedData.status !== "Approved") {
          throw new errors.TxRejectedError(
            `Request not approved. Status: ${signedData.status}. Message: ${signedData.message || "No message provided"}`
          );
        }
        return signedData;
      } catch (error) {
        throw (_c = parseApiError(error)) != null ? _c : parseServerError(error);
      }
    });
  }
  /**
   * Approves a transaction request.
   * @param {ethers.TransactionRequest} txData - The transaction request to approve. Must include to, from, value and data. Chain ID is optional.
   * @param {string} txData.to - The recipient address of the transaction (required)
   * @param {string} txData.from - The sender address of the transaction (required)
   * @param {string} txData.value - The amount of Ether to send with the transaction (required)
   * @param {string} txData.data - The data payload of the transaction (required)
   * @param {number} [txData.chainId] - Chain ID to which the transaction will be sent (optional). If omitted, the chain ID currently set in the user's wallet will be used. If unavailable, the transaction will fail
   * @returns {ethers.TransactionRequest} The approved transaction request. Includes a from, to, value and data
   * @throws {Error} If strict is true, and the transaction request is not approved or an error occurs. If strict set to false, will return the transaction request on failure
   */
  approve(txData) {
    return __async(this, null, function* () {
      try {
        const { data } = yield this.getSignature(txData);
        return data;
      } catch (error) {
        return this.handleError(error, txData);
      }
    });
  }
  validateRequiredProperties(opts) {
    if (!opts.vennURL || !opts.vennPolicyAddress) {
      throw new errors.InvalidInitParamsError(
        "Missing required properties: `vennURL` and `vennPolicyAddress` are required."
      );
    }
    if (!isValidUrl(opts.vennURL)) {
      throw new errors.InvalidInitParamsError("Invalid `vennURL` provided.");
    }
    if (!isValidEthereumAddress(opts.vennPolicyAddress)) {
      throw new errors.InvalidInitParamsError("Invalid Ethereum address provided for `vennPolicyAddress`.");
    }
  }
  handleError(error, txData) {
    if (this.strict) throw error;
    return txData;
  }
};
export {
  VennClient,
  errors
};
//# sourceMappingURL=index.mjs.map