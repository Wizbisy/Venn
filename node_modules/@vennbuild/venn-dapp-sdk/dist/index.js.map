{"version":3,"sources":["../index.ts","../src/errors/api.errors.ts","../src/errors/server.errors.ts","../src/errors/venn-client.errors.ts","../src/errors/index.ts","../src/venn-client/index.ts","../src/helpers/error.helpers.ts","../src/helpers/validation.helpers.ts"],"sourcesContent":["export * from '@/errors'\nexport * from '@/types/server.types'\nexport { VennClient } from '@/venn-client'\n","export { CanceledError } from 'axios'\n\nexport class ConnectionRefusedError extends Error {\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class NetworkError extends Error {\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class TimeoutError extends Error {\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class AbortedError extends Error {\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class BadRequestError extends Error {\n    constructor(message?: string) {\n        super(message)\n    }\n}\n","export class TxRejectedError extends Error {\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class NoPolicyCallInTraceError extends Error {\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class NoMonitoredAssetsError extends Error {\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class InternalError extends Error {\n    constructor(message?: string) {\n        super(message)\n    }\n}\n","export class InvalidInitParamsError extends Error {\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class MissingChainIdError extends Error {\n    constructor(message?: string) {\n        super(message)\n    }\n}\n","import * as apiErrors from './api.errors'\nimport * as serverErrors from './server.errors'\nimport * as vennClientErrors from './venn-client.errors'\n\nexport const errors = {\n    ...serverErrors,\n    ...apiErrors,\n    ...vennClientErrors,\n}\n","import {\n    CoinbaseProvider,\n    createProvider,\n    errors as web3Errors,\n    MetamaskProvider,\n    Provider,\n    ProviderDetector,\n    ProviderProxyConstructor,\n    PROVIDERS,\n} from '@distributedlab/w3p'\nimport axios, { AxiosInstance } from 'axios'\nimport { TransactionRequest } from 'ethers'\n\nimport { errors } from '@/errors'\nimport { isValidEthereumAddress, isValidUrl, parseApiError, parseServerError } from '@/helpers'\nimport { type SignedTxResponse, type SignTxServerRequest } from '@/types'\n\nconst supportedProviders: {\n    [key in VennSupportedProviders]: ProviderProxyConstructor\n} = {\n    [PROVIDERS.Metamask]: MetamaskProvider,\n    [PROVIDERS.Coinbase]: CoinbaseProvider,\n}\n\nexport type VennSupportedProviders = PROVIDERS.Metamask | PROVIDERS.Coinbase\n\nexport type VennClientCreateOpts = {\n    vennURL: string\n    vennPolicyAddress: string\n    strict?: boolean\n}\n\nexport class VennClient {\n    protected url: string\n\n    protected vennPolicyAddress: string\n\n    protected apiInstance: AxiosInstance\n\n    protected strict: boolean\n\n    protected web3Provider?: Provider\n\n    /**\n     * Creates a new VennClient instance.\n     * @param {string} opts.url - The URL of the Venn Node.\n     * @param {string} opts.vennPolicyAddress - The address of the policy.\n     * @param {boolean} [opts.strict=true] - Optional. Whether to throw an error if the response Venn Network is not 'Approved' or if an error occurs. If set to false, will return the request data on failure. Defaults to true.\n     * @throws {Error} If any required property is missing.\n     */\n    constructor(opts: VennClientCreateOpts) {\n        this.validateRequiredProperties(opts)\n\n        this.initProvider()\n\n        this.url = opts.vennURL\n        this.vennPolicyAddress = opts.vennPolicyAddress\n        this.strict = opts.strict ?? true\n\n        this.apiInstance = axios.create({ baseURL: this.url })\n    }\n\n    protected async initProvider() {\n        if (typeof window === 'undefined') return\n\n        try {\n            const providerDetector = new ProviderDetector()\n\n            await providerDetector.init()\n\n            const availableProviders = Object.keys(providerDetector.providers) as VennSupportedProviders[]\n\n            if (!availableProviders.length) throw new web3Errors.ProviderInjectedInstanceNotFoundError()\n\n            const providerProxyConstructor = supportedProviders[availableProviders[0]]\n\n            this.web3Provider = await createProvider(providerProxyConstructor, { providerDetector: providerDetector })\n        } catch (error) {\n            console.warn(\n                `Web3Provider in VennClient was not initialized: ${\n                    error instanceof Error ? error.message : String(error)\n                }`,\n            )\n        }\n    }\n\n    protected async getSignature(txData: TransactionRequest): Promise<SignedTxResponse> {\n        try {\n            const requestData: SignTxServerRequest = {\n                ...txData,\n                approvingPolicyAddress: this.vennPolicyAddress,\n                chainId: txData?.chainId ?? this.web3Provider?.chainId,\n            }\n\n            if (!requestData.chainId)\n                throw new errors.MissingChainIdError(\n                    'Chain id was not provided in request and was not available via injected provider',\n                )\n\n            const { data: signedData } = await this.apiInstance.post<SignedTxResponse>('', requestData)\n\n            // some errors come with 200 status ^_^\n            if (signedData.status !== 'Approved') {\n                throw new errors.TxRejectedError(\n                    `Request not approved. Status: ${signedData.status}. Message: ${\n                        signedData.message || 'No message provided'\n                    }`,\n                )\n            }\n\n            return signedData\n        } catch (error) {\n            // first checking default http errors then Venn Node specific ones\n            throw parseApiError(error) ?? parseServerError(error)\n        }\n    }\n\n    /**\n     * Approves a transaction request.\n     * @param {ethers.TransactionRequest} txData - The transaction request to approve. Must include to, from, value and data. Chain ID is optional.\n     * @param {string} txData.to - The recipient address of the transaction (required)\n     * @param {string} txData.from - The sender address of the transaction (required)\n     * @param {string} txData.value - The amount of Ether to send with the transaction (required)\n     * @param {string} txData.data - The data payload of the transaction (required)\n     * @param {number} [txData.chainId] - Chain ID to which the transaction will be sent (optional). If omitted, the chain ID currently set in the user's wallet will be used. If unavailable, the transaction will fail\n     * @returns {ethers.TransactionRequest} The approved transaction request. Includes a from, to, value and data\n     * @throws {Error} If strict is true, and the transaction request is not approved or an error occurs. If strict set to false, will return the transaction request on failure\n     */\n    public async approve(txData: TransactionRequest): Promise<TransactionRequest> {\n        try {\n            const { data } = await this.getSignature(txData)\n\n            return data\n        } catch (error) {\n            return this.handleError(error, txData)\n        }\n    }\n\n    private validateRequiredProperties(opts: VennClientCreateOpts) {\n        if (!opts.vennURL || !opts.vennPolicyAddress) {\n            throw new errors.InvalidInitParamsError(\n                'Missing required properties: `vennURL` and `vennPolicyAddress` are required.',\n            )\n        }\n\n        if (!isValidUrl(opts.vennURL)) {\n            throw new errors.InvalidInitParamsError('Invalid `vennURL` provided.')\n        }\n\n        if (!isValidEthereumAddress(opts.vennPolicyAddress)) {\n            throw new errors.InvalidInitParamsError('Invalid Ethereum address provided for `vennPolicyAddress`.')\n        }\n    }\n\n    private handleError(error: unknown, txData: TransactionRequest): TransactionRequest {\n        if (this.strict) throw error\n\n        return txData\n    }\n}\n","import { AxiosError, isAxiosError } from 'axios'\n\nimport { errors } from '@/errors'\nimport { API_ERROR_CODE, TxStatus } from '@/types'\n\ntype ResponseData = {\n    message: string\n    status: TxStatus\n    data: unknown\n}\n\nconst isLegacyServerLikeError = (error: AxiosError) =>\n    typeof error === 'object' &&\n    error !== null &&\n    typeof error.response?.data === 'object' &&\n    error.response?.data !== null &&\n    ['message', 'status'].every(prop => Reflect.has(error.response?.data as object, prop))\n\nexport const parseServerError = (error: unknown) => {\n    if (!isAxiosError(error)) return error\n    if (!isLegacyServerLikeError(error)) return error\n\n    const responseData = (error as AxiosError).response?.data as ResponseData\n    const message = responseData.message\n    const status = responseData.status\n\n    // not sure if this is still relevant\n    const _parseServerError = (message: string) => {\n        const _message = message.toLowerCase()\n\n        switch (true) {\n            case _message.includes('policy'):\n                return new errors.NoPolicyCallInTraceError(message)\n            case _message.includes('invalid request'):\n                return new errors.BadRequestError(message)\n            case _message.includes('monitored assets'):\n                return new errors.NoMonitoredAssetsError(message)\n            default:\n                return new errors.InternalError(message)\n        }\n    }\n\n    switch (status) {\n        case 'Rejected':\n            return new errors.TxRejectedError(message)\n        case 'Error':\n            return _parseServerError(message)\n        default:\n            return new errors.InternalError(message)\n    }\n}\n\nexport const parseApiError = (error: unknown) => {\n    if (!isAxiosError(error)) return null\n\n    switch (error.code) {\n        case API_ERROR_CODE.connectionRefused:\n            return new errors.ConnectionRefusedError(error.message)\n        case API_ERROR_CODE.network:\n            return new errors.NetworkError(error.message)\n        case API_ERROR_CODE.timeout:\n            return new errors.TimeoutError(error.message)\n        case API_ERROR_CODE.aborted:\n            return new errors.AbortedError(error.message)\n        case API_ERROR_CODE.badRequest:\n            return new errors.BadRequestError(error.message)\n        default:\n            return null\n    }\n}\n","import { isAddress } from 'ethers'\n\nexport const isValidUrl = (url: string) => {\n    try {\n        new URL(url)\n        return true\n    } catch {\n        return false\n    }\n}\n\nexport const isValidEthereumAddress = (address: unknown) => isAddress(address)\n"],"mappings":"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","names":["import_axios","import_axios","_a","message","axios","web3Errors"]}