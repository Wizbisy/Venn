import { CanceledError, AxiosInstance } from 'axios';
import { ethers, TransactionRequest } from 'ethers';
import { Provider } from '@distributedlab/w3p';

declare class ConnectionRefusedError extends Error {
    constructor(message?: string);
}
declare class NetworkError extends Error {
    constructor(message?: string);
}
declare class TimeoutError extends Error {
    constructor(message?: string);
}
declare class AbortedError extends Error {
    constructor(message?: string);
}
declare class BadRequestError extends Error {
    constructor(message?: string);
}

declare class TxRejectedError extends Error {
    constructor(message?: string);
}
declare class NoPolicyCallInTraceError extends Error {
    constructor(message?: string);
}
declare class NoMonitoredAssetsError extends Error {
    constructor(message?: string);
}
declare class InternalError extends Error {
    constructor(message?: string);
}

declare class InvalidInitParamsError extends Error {
    constructor(message?: string);
}
declare class MissingChainIdError extends Error {
    constructor(message?: string);
}

declare const errors: {
    InvalidInitParamsError: typeof InvalidInitParamsError;
    MissingChainIdError: typeof MissingChainIdError;
    CanceledError: typeof CanceledError;
    ConnectionRefusedError: typeof ConnectionRefusedError;
    NetworkError: typeof NetworkError;
    TimeoutError: typeof TimeoutError;
    AbortedError: typeof AbortedError;
    BadRequestError: typeof BadRequestError;
    TxRejectedError: typeof TxRejectedError;
    NoPolicyCallInTraceError: typeof NoPolicyCallInTraceError;
    NoMonitoredAssetsError: typeof NoMonitoredAssetsError;
    InternalError: typeof InternalError;
};

type TxStatus = 'Approved' | 'Rejected' | 'Error';
type SignedTxResponse = {
    requestId: string;
    status: TxStatus;
    data: ethers.TransactionRequest;
    message?: string;
};
type SignTxServerRequest = ethers.TransactionRequest & {
    approvingPolicyAddress: string;
};

type VennClientCreateOpts = {
    vennURL: string;
    vennPolicyAddress: string;
    strict?: boolean;
};
declare class VennClient {
    protected url: string;
    protected vennPolicyAddress: string;
    protected apiInstance: AxiosInstance;
    protected strict: boolean;
    protected web3Provider?: Provider;
    /**
     * Creates a new VennClient instance.
     * @param {string} opts.url - The URL of the Venn Node.
     * @param {string} opts.vennPolicyAddress - The address of the policy.
     * @param {boolean} [opts.strict=true] - Optional. Whether to throw an error if the response Venn Network is not 'Approved' or if an error occurs. If set to false, will return the request data on failure. Defaults to true.
     * @throws {Error} If any required property is missing.
     */
    constructor(opts: VennClientCreateOpts);
    protected initProvider(): Promise<void>;
    protected getSignature(txData: TransactionRequest): Promise<SignedTxResponse>;
    /**
     * Approves a transaction request.
     * @param {ethers.TransactionRequest} txData - The transaction request to approve. Must include to, from, value and data. Chain ID is optional.
     * @param {string} txData.to - The recipient address of the transaction (required)
     * @param {string} txData.from - The sender address of the transaction (required)
     * @param {string} txData.value - The amount of Ether to send with the transaction (required)
     * @param {string} txData.data - The data payload of the transaction (required)
     * @param {number} [txData.chainId] - Chain ID to which the transaction will be sent (optional). If omitted, the chain ID currently set in the user's wallet will be used. If unavailable, the transaction will fail
     * @returns {ethers.TransactionRequest} The approved transaction request. Includes a from, to, value and data
     * @throws {Error} If strict is true, and the transaction request is not approved or an error occurs. If strict set to false, will return the transaction request on failure
     */
    approve(txData: TransactionRequest): Promise<TransactionRequest>;
    private validateRequiredProperties;
    private handleError;
}

export { type SignTxServerRequest, type SignedTxResponse, type TxStatus, VennClient, errors };
